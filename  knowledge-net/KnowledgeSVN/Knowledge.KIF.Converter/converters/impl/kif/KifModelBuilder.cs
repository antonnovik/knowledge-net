/*
 * Created by: M. Sigalin
 */

using System;
using System.Collections;
using System.Collections.Generic;
using Knowledge.KIF.Converter.model;
using Knowledge.KIF.Converter.model.kif;
using Knowledge.KIF.Converter.util;

//TODO: 
/*
 * Except for characters following \, the lexical analysis of words is case insensitive. 
 * The output lexeme for any word corresponds to the lexeme obtained by converting all 
 * letters not following \ to their upper case equivalents. For example, the word abc 
 * and the word ABC map into the same lexeme. The word a\bc maps into the same lexeme 
 * as the word A\bC, which is not the same as the lexeme for the word ABC, since the 
 * second character is lower case. 
 */

namespace Knowledge.KIF.Converter.converters.impl.kif {
    public class KifModelBuilder : IModelBuilder {

        private static readonly string DOCUMENTATION = "Documentation";//TODO:
        private static readonly string SUBCLASS_OF = "Subclass-of";//TODO:
        private static readonly string ARITY = "Arity";//TODO:
        private static readonly string THING = "Thing";//TODO:
        private static readonly string CLASS = "Class";//TODO:
        private static readonly string RANGE = "Range";//TODO:   
        private static readonly string DOMAIN = "Domain";//TODO:
        private static readonly string RELATION = "Relation";//TODO:
        private static readonly string BINARY_RELATION = "Binary-Relation";//TODO:
        private static readonly string TEMPLATE_SLOT_VALUE = "Template-Slot-Value";//TODO:
                
        private KifModel _model;

        private Converter _director;//TODO:
        private TypeResolver _resolver;
        
        public KifModelBuilder() {//TODO: method start
            _model = new KifModel();
            _model.addObject(new KifComment("Generated by Knowledge.NET KIFConverter"));
            _resolver = TypeResolver.getInstance();
        }

        public IModel getModel() {//TODO:
            return _model;
        }

        protected string generateSlotIdentifier(string frameName, string slotName) {
            return frameName + "." + slotName;//TODO:
        }

        protected string generateFrameComment(bool isClassFrame, string frameName) {
            return (isClassFrame ? "Class frame " : "Instance frame ") + frameName;
        }

        protected string generateSlotComment(bool isOwnSlot, string slotName, string frameName) {
            return (isOwnSlot ? "Own slot " : "Instance slot ") + slotName + " of frame " + frameName;
        }

        protected KifRelationalSentence createDocumentation(string docString, string docOwner) {
            KifSequence<KifTerm> terms = new KifSequence<KifTerm>(new KifConstant(docOwner));
            terms.addItem(new KifString(docString));
            return new KifRelationalSentence(new KifConstant(DOCUMENTATION), terms);
        }

        protected KifRelationalSentence createTrRelation(string relName, string firstArg, string secondArg, string thirdArg) {//TODO
            KifSequence<KifTerm> terms = new KifSequence<KifTerm>(new KifConstant(firstArg));
            terms.addItem(new KifConstant(secondArg));
            terms.addItem(new KifConstant(thirdArg));
            return new KifRelationalSentence(new KifConstant(relName), terms);
        }
        protected KifRelationalSentence createBinRelation(string relName, string firstArg, string secondArg) {//TODO
            KifSequence<KifTerm> terms = new KifSequence<KifTerm>(new KifConstant(firstArg));
            terms.addItem(new KifConstant(secondArg));
            return new KifRelationalSentence(new KifConstant(relName), terms);
        }

        protected KifRelationalSentence createUnRelation(string relName, string arg) {//TODO
            return new KifRelationalSentence(new KifConstant(relName), new KifSequence<KifTerm>(new KifConstant(arg)));
        }

        protected KifRelationalSentence createSubclassOf(string frameName, string parentFrameName) {
            return createBinRelation(SUBCLASS_OF, frameName, parentFrameName);
        }

        protected KifRelationalSentence createArity(string name, int num) {
            return createBinRelation(ARITY, name, num.ToString());
        }
        
        protected bool isOwnSlot(Slot slot) {
            return slot.category == Slot.SlotCategory.OwnSlot;
        }
        
        protected KifObject createSlot(string frameName, Slot slot, KifSequence<KifSentence> slotsValues) {
            string slotIden = generateSlotIdentifier(frameName, slot.iden);
            KifSequence<KifSentence> sequence = new KifSequence<KifSentence>(createDocumentation(generateSlotComment(isOwnSlot(slot), slot.iden, frameName), frameName));
            sequence.addItem(createBinRelation(RANGE, slotIden, _resolver.resolveType(slot.slotType)));
            sequence.addItem(createBinRelation(DOMAIN, slotIden, frameName));
            sequence.addItem(createArity(slotIden, 2));
            sequence.addItem(createUnRelation(RELATION, slotIden));
            sequence.addItem(createUnRelation(BINARY_RELATION, slotIden));

//            bool isString = StringUtils.equalsIgnoreCase(slot.slotType, "string"); 
//            if (slot.slotValue != null && (!"".Equals(slot.slotValue) && isString))
//                slotsValues.addItem(createTrRelation(TEMPLATE_SLOT_VALUE, slotIden, frameName, slot.slotValue));
            if (!StringUtils.isEmpty(slot.slotValue))
                slotsValues.addItem(createTrRelation(TEMPLATE_SLOT_VALUE, slotIden, frameName, slot.slotValue));

            return new KifRelationDefinition(slotIden, sequence);
        }

        protected IList<KifObject> createOwnSlots(DataFrame frame, KifSequence<KifSentence> slotsValues) {
            List<KifObject> result = new List<KifObject>(frame.ownSlots.Count);
            foreach (Slot slot in frame.ownSlots.Values) {
                string owner = _director.getSlotOwner(slot.iden, frame);
                if (frame.iden.Equals(owner))
                    result.Add(createSlot(frame.iden, slot, slotsValues));
                else {
                    if (slot.slotValue != null)
                        slotsValues.addItem(createTrRelation(TEMPLATE_SLOT_VALUE, generateSlotIdentifier(owner, slot.iden), frame.iden, slot.slotValue));
                }
            }
            return result;
        }
        
        protected IList<KifObject> createSlots(DataFrame frame, KifSequence<KifSentence> slotsValues) {
            List<KifObject> result = new List<KifObject>(createOwnSlots(frame, slotsValues));
            foreach (Slot slot in frame.instanceSlots.Values) {
                result.Add(createSlot(frame.iden, slot, slotsValues));
            }
            return result;
        }

        protected KifSequence<KifSentence> processingParentsXXX(DataFrame frame) {
            KifSequence<KifSentence> parents = new KifSequence<KifSentence>();
            string frameName = frame.iden;
            IList isA = frame.isA;
            if (isA.Count == 0)
                parents.addItem(createSubclassOf(frameName, THING));
            else {
                foreach (string parentName in isA) {
                    parents.addItem(createSubclassOf(frameName, parentName));
                }
            }
            return parents;
        }

        public void createClassFrame(DataFrame frame) {//TODO: order
            string frameName = frame.iden;
            KifSequence<KifSentence> sequence = new KifSequence<KifSentence>(createDocumentation(generateFrameComment(true, frameName), frameName));
            sequence.addRange(processingParentsXXX(frame));
            sequence.addItem(createArity(frameName, 1));
            sequence.addItem(createUnRelation(CLASS, frameName));
            IList<KifObject> slots = createSlots(frame, sequence);
            KifRelationDefinition relation = new KifRelationDefinition(frame.iden, sequence);
            _model.addObject(relation);
            _model.addRange(slots);
        }

        protected KifSequence<KifSentence> processingParentsOfInstance(DataFrame frame) {
            KifSequence<KifSentence> parents = new KifSequence<KifSentence>();
            string frameName = frame.iden;
            IList isA = frame.isA;
            if (isA.Count == 0)
                parents.addItem(createUnRelation(THING, frameName));
            else {
                foreach (string parentName in isA) {
                    parents.addItem(createUnRelation(parentName, frameName));
                }
            }
            return parents;
        }

        protected KifObject createSlotOfInstance(string frameName, Slot slot, KifSequence<KifSentence> slotsValues) {
            string slotIden = generateSlotIdentifier(frameName, slot.iden);
            KifSequence<KifSentence> sequence = new KifSequence<KifSentence>(createDocumentation(generateSlotComment(isOwnSlot(slot), slot.iden, frameName), frameName));
            sequence.addItem(createBinRelation(RANGE, slotIden, _resolver.resolveType(slot.slotType)));
            sequence.addItem(createBinRelation(DOMAIN, slotIden, frameName));
            sequence.addItem(createArity(slotIden, 2));
            sequence.addItem(createUnRelation(RELATION, slotIden));
            sequence.addItem(createUnRelation(BINARY_RELATION, slotIden));

            return new KifRelationDefinition(slotIden, sequence);
        }
        
        protected IList<KifObject> createOwnSlotsOfInstance(DataFrame frame, KifSequence<KifSentence> slotsValues) {
            List<KifObject> result = new List<KifObject>(frame.ownSlots.Count);
            foreach (Slot slot in frame.ownSlots.Values) {
                string owner = _director.getSlotOwner(slot.iden, frame);
                if (frame.iden.Equals(owner))
                    result.Add(createSlotOfInstance(frame.iden, slot, slotsValues));
                if (!StringUtils.isEmpty(slot.slotValue))
                    slotsValues.addItem(createBinRelation(generateSlotIdentifier(owner, slot.iden), frame.iden, slot.slotValue));
            }
            return result;
        }        
        
        
 /*       protected IList<KifObject> createSlotsOfInstance(DataFrame frame, KifSequence<KifSentence> slotsValues) {
            List<KifObject> result = new List<KifObject>(createOwnSlotsOfInstance(frame, slotsValues));
            foreach (Slot slot in frame.ownSlots.Values) {
                result.Add(createSlotOfInstance(frame.iden, slot, slotsValues));
            }
            return result;
        }     */   
        
        public void createInstanceFrame(DataFrame frame) {
            string frameName = frame.iden;
            KifSequence<KifSentence> sequence = new KifSequence<KifSentence>(createDocumentation(generateFrameComment(false, frameName), frameName));
            sequence.addRange(processingParentsOfInstance(frame));
            IList<KifObject> slots = createOwnSlotsOfInstance(frame, sequence);
            KifObjectDefinition relation = new KifObjectDefinition(frame.iden, sequence);
            _model.addObject(relation);
            _model.addRange(slots);
        }

        public void createConcept() {
            throw new NotImplementedException();
        }

        public void createProperty() {
            throw new NotImplementedException();
        }

        public void setDirector(Converter converter) {
            _director = converter;
        }
    }
}