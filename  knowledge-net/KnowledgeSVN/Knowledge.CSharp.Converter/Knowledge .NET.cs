// Compiled by vsCoco on 28.09.2006 3:20:56
/*----------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
----------------------------------------------------------------------*/

#line hidden
using System.Collections;
using System.Text;
using System.Reflection;
using Knowledge;
#line hidden


//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by COCO from Parser.frame.
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

using System;
using System.IO;
using System.Collections;

namespace Knowledge {


	public class Parser {
	const int _EOF = 0;
	const int _ident = 1;
	const int _intCon = 2;
	const int _realCon = 3;
	const int _charCon = 4;
	const int _stringCon = 5;
	const int _abstract = 6;
	const int _as = 7;
	const int _base = 8;
	const int _bool = 9;
	const int _break = 10;
	const int _byte = 11;
	const int _case = 12;
	const int _catch = 13;
	const int _char = 14;
	const int _checked = 15;
	const int _class = 16;
	const int _const = 17;
	const int _continue = 18;
	const int _decimal = 19;
	const int _default = 20;
	const int _delegate = 21;
	const int _do = 22;
	const int _double = 23;
	const int _else = 24;
	const int _enum = 25;
	const int _event = 26;
	const int _explicit = 27;
	const int _extern = 28;
	const int _false = 29;
	const int _finally = 30;
	const int _fixed = 31;
	const int _float = 32;
	const int _for = 33;
	const int _foreach = 34;
	const int _goto = 35;
	const int _if = 36;
	const int _implicit = 37;
	const int _in = 38;
	const int _int = 39;
	const int _interface = 40;
	const int _internal = 41;
	const int _is = 42;
	const int _lock = 43;
	const int _long = 44;
	const int _namespace = 45;
	const int _new = 46;
	const int _null = 47;
	const int _object = 48;
	const int _operator = 49;
	const int _out = 50;
	const int _override = 51;
	const int _params = 52;
	const int _private = 53;
	const int _protected = 54;
	const int _public = 55;
	const int _readonly = 56;
	const int _ref = 57;
	const int _return = 58;
	const int _sbyte = 59;
	const int _sealed = 60;
	const int _short = 61;
	const int _sizeof = 62;
	const int _stackalloc = 63;
	const int _static = 64;
	const int _string = 65;
	const int _struct = 66;
	const int _switch = 67;
	const int _this = 68;
	const int _throw = 69;
	const int _true = 70;
	const int _try = 71;
	const int _typeof = 72;
	const int _uint = 73;
	const int _ulong = 74;
	const int _unchecked = 75;
	const int _unsafe = 76;
	const int _ushort = 77;
	const int _usingKW = 78;
	const int _virtual = 79;
	const int _void = 80;
	const int _volatile = 81;
	const int _while = 82;
	const int _and = 83;
	const int _andassgn = 84;
	const int _assgn = 85;
	const int _colon = 86;
	const int _comma = 87;
	const int _dec = 88;
	const int _divassgn = 89;
	const int _dot = 90;
	const int _dblcolon = 91;
	const int _eq = 92;
	const int _gt = 93;
	const int _gteq = 94;
	const int _inc = 95;
	const int _lbrace = 96;
	const int _lbrack = 97;
	const int _lpar = 98;
	const int _lshassgn = 99;
	const int _lt = 100;
	const int _ltlt = 101;
	const int _minus = 102;
	const int _minusassgn = 103;
	const int _modassgn = 104;
	const int _neq = 105;
	const int _not = 106;
	const int _orassgn = 107;
	const int _plus = 108;
	const int _plusassgn = 109;
	const int _question = 110;
	const int _rbrace = 111;
	const int _rbrack = 112;
	const int _rpar = 113;
	const int _scolon = 114;
	const int _tilde = 115;
	const int _times = 116;
	const int _timesassgn = 117;
	const int _xorassgn = 118;
	const int maxT = 171;
	const int _ppDefine = 172;
	const int _ppUndef = 173;
	const int _ppIf = 174;
	const int _ppElif = 175;
	const int _ppElse = 176;
	const int _ppEndif = 177;
	const int _ppLine = 178;
	const int _ppError = 179;
	const int _ppWarning = 180;
	const int _ppRegion = 181;
	const int _ppEndReg = 182;

		const bool T = true;
		const bool x = false;
		const int minErrDist = 2;
		
		public Scanner scanner;
		public Errors  errors;

		public Token t;    // last recognized token
		public Token la;   // lookahead token
		int errDist = minErrDist;


#line hidden
ArrayList ccs = new ArrayList();

public void AddConditionalCompilationSymbols(String[] symbols) {
  if (symbols != null) {
    for (int i=0; i<symbols.Length; ++i) {
      symbols[i] = symbols[i].Trim();
      if (symbols[i].Length > 0 && !ccs.Contains(symbols[i])) {
        ccs.Add(symbols[i]);
      }
    }
  }
}

// returns the end of the whitespaces in the given
// string if whitespaces is true otherwise returns
// the end of the non-whitespaces.
int EndOf(String symbol, int start, bool whitespaces) {
  while ((start < symbol.Length) && (Char.IsWhiteSpace(symbol[start]) ^ !whitespaces)) {
    ++start;
  }
  
  return start;
}

// input:        "#" {ws} directive ws {ws} {not-newline} {newline}
// valid input:  "#" {ws} directive ws {ws} {non-ws} {ws} {newline}
// output:       {non-ws}
String RemPPDirective(String symbol) {  
  int start = 1;
  int end;

  // skip {ws}
  start = EndOf(symbol, start, true);
  // skip directive  
  start = EndOf(symbol, start, false);
  // skip ws {ws}
  start = EndOf(symbol, start, true);
  // search end of symbol
  end = EndOf(symbol, start, false);  
  
  return symbol.Substring(start, end - start);
}

void AddCCS(String symbol) {
  symbol = RemPPDirective(symbol);
  if (!ccs.Contains(symbol)) {
    ccs.Add(symbol);
  }
}

void RemCCS(String symbol) {
  ccs.Remove(RemPPDirective(symbol));
}

bool IsCCS(String symbol) {
  return ccs.Contains(RemPPDirective(symbol));
}

// search for the correct alternative and enter
// drop everything before the correct alternative
void IfPragma(String symbol) {
  if (!IsCCS(symbol)) { 
    int state = 0;
    Token cur = scanner.Scan();
    
    for (;;) {
      switch (cur.kind) {
        case _ppIf: ++state; break;
        case _ppEndif:
          if (state == 0) { return; }
          --state;
        break;
        case _ppElif:
          if (state == 0 && IsCCS(cur.val)) { return; }
        break;
        case _ppElse:
          if (state == 0) { return; }
        break;
        default: break;
      }
      cur = scanner.Scan();
    }
  }
}

// drop everything until the end of this if, elif, else directive
void ElifOrElsePragma() {
  int state = 0;
  Token cur = scanner.Scan();
  
  for (;;) {
    switch (cur.kind) {
      case _ppIf: ++state; break;
      case _ppEndif:
        if (state == 0) { return; }
        --state;
      break;
      default: break;
    }
    cur = scanner.Scan();
  }
}

/*----------------------------- token sets -------------------------------*/

const int maxTerminals = 160;  // set size

static BitArray NewSet(params int[] values) {
  BitArray a = new BitArray(maxTerminals);
  foreach (int x in values) a[x] = true;
  return a;
}

static BitArray
  unaryOp      = NewSet(_plus, _minus, _not, _tilde, _inc, _dec, _true, _false),
  typeKW       = NewSet(_char, _bool, _object, _string, _sbyte, _byte, _short,
                 _ushort, _int, _uint, _long, _ulong, _float, _double, _decimal),
  unaryHead    = NewSet(_plus, _minus, _not, _tilde, _times, _inc, _dec, _and),
  assnStartOp  = NewSet(_plus, _minus, _not, _tilde, _times),
  castFollower = NewSet(_tilde, _not, _lpar, _ident,
			     /* literals */
			     _intCon, _realCon, _charCon, _stringCon,
			     /* any keyword expect as and is */
			     _abstract, _base, _bool, _break, _byte, _case, _catch,
			     _char, _checked, _class, _const, _continue, _decimal, _default,
			     _delegate, _do, _double, _else, _enum, _event, _explicit,
			     _extern, _false, _finally, _fixed, _float, _for, _foreach,
			     _goto, _if, _implicit, _in, _int, _interface, _internal,
			     _lock, _long, _namespace, _new, _null, _object, _operator,
			     _out, _override, _params, _private, _protected, _public,
			     _readonly, _ref, _return, _sbyte, _sealed, _short, _sizeof,
			     _stackalloc, _static, _string, _struct, _switch, _this, _throw,
			     _true, _try, _typeof, _uint, _ulong, _unchecked, _unsafe,
			     _ushort, _usingKW, _virtual, _void, _volatile, _while
			     ),
  typArgLstFol = NewSet ( _lpar, _rpar, _rbrack, _colon, _scolon, _comma, _dot,
                 _question, _eq, _neq ),
  keyword      = NewSet(_abstract, _as, _base, _bool, _break, _byte, _case, _catch,
                 _char, _checked, _class, _const, _continue, _decimal, _default,
                 _delegate, _do, _double, _else, _enum, _event, _explicit,
                 _extern, _false, _finally, _fixed, _float, _for, _foreach,
                 _goto, _if, _implicit, _in, _int, _interface, _internal,
                 _is, _lock, _long, _namespace, _new, _null, _object, _operator,
                 _out, _override, _params, _private, _protected, _public,
                 _readonly, _ref, _return, _sbyte, _sealed, _short, _sizeof,
                 _stackalloc, _static, _string, _struct, _switch, _this, _throw,
                 _true, _try, _typeof, _uint, _ulong, _unchecked, _unsafe,
                 _ushort, _usingKW, _virtual, _void, _volatile, _while),
  assgnOps     = NewSet(_assgn, _plusassgn, _minusassgn, _timesassgn, _divassgn,
                 _modassgn, _andassgn, _orassgn, _xorassgn, _lshassgn) /* rshassgn: ">" ">="  no whitespace allowed*/
                 ;

/*---------------------------- auxiliary methods ------------------------*/

void Error (string s) {
  if (errDist >= minErrDist) errors.Error(la.line, la.col, s);
  errDist = 0;
}

// Return the n-th token after the current lookahead token
Token Peek (int n) {
  scanner.ResetPeek();
  Token x = la;
  while (n > 0) { x = scanner.Peek(); n--; }
  return x;
}

// ident "="
bool IsAssignment () {
  return la.kind == _ident && Peek(1).kind == _assgn;
}

/* True, if the comma is not a trailing one, *
 * like the last one in: a, b, c,            */
bool NotFinalComma () {
  int peek = Peek(1).kind;
  return la.kind == _comma && peek != _rbrace && peek != _rbrack;
}

/* Checks whether the next sequence of tokens is a qualident *
 * and returns the qualident string                          *
 * !!! Proceeds from current peek position !!!               */
bool IsQualident (ref Token pt, out string qualident) {
	qualident = "";
	if (pt.kind == _ident) {
		qualident = pt.val;
		pt = scanner.Peek();
		while (pt.kind == _dot) {
			pt = scanner.Peek();
			if (pt.kind != _ident) return false;
			qualident += "." + pt.val;
			pt = scanner.Peek();
		}
		return true;
	} else return false;
}

bool IsGeneric() {
  scanner.ResetPeek();
  Token pt = la;
  if (!IsTypeArgumentList(ref pt)) {
    return false;
  }
  return typArgLstFol[pt.kind];
}

bool IsTypeArgumentList(ref Token pt) {
  if (pt.kind == _lt) {
    pt = scanner.Peek();
    while (true) {
      if (!IsType(ref pt)) {
        return false;
      }
      if (pt.kind == _gt) {
        // list recognized
        pt = scanner.Peek();
        break;
      } else if (pt.kind == _comma) {
        // another argument
        pt = scanner.Peek();
      } else {
        // error in type argument list
        return false;
      }
    }
  } else {
    return false;
  }
  return true;
}

// Type
bool IsType (ref Token pt) {
  String dummyId;
  
  if (typeKW[pt.kind]) {
    pt = scanner.Peek();
  } else if (pt.kind == _void) {
    pt = scanner.Peek();
    if (pt.kind != _times) {
      return false;
    }
    pt = scanner.Peek();
  } else if (pt.kind == _ident) {
    pt = scanner.Peek();
    if (pt.kind == _dblcolon || pt.kind == _dot) {
      // either namespace alias qualifier "::" or first
      // part of the qualident
      pt = scanner.Peek();
      if (!IsQualident(ref pt, out dummyId)) {
        return false;
      }
    } 
    if (pt.kind == _lt && !IsTypeArgumentList(ref pt)) {
      return false;
    }
  } else {
    return false;
  }
  return SkipPointerOrDims(ref pt);
}

// Type ident
// (Type can be void*)
bool IsLocalVarDecl() {
  Token pt = la;
  scanner.ResetPeek();
  return IsType(ref pt) && pt.kind == _ident;
}

// "[" ("," | "]")
bool IsDims () {
  int peek = Peek(1).kind;
  return la.kind == _lbrack && (peek == _comma || peek == _rbrack);
}

// "*" | "[" ("," | "]")
bool IsPointerOrDims () {
  return la.kind == _times || IsDims();
}

/* skip: { "[" { "," } "]" | "*" }             */
/* !!! Proceeds from current peek position !!! */
bool SkipPointerOrDims (ref Token pt) {
  for (;;) {
    if (pt.kind == _lbrack) {
      do pt = scanner.Peek();
      while (pt.kind == _comma);
      if (pt.kind != _rbrack) return false;
    } else if (pt.kind != _times) break;
    pt = scanner.Peek();
  }
  return true;
}

// Is attribute target specifier
// (ident | keyword) ":"
bool IsAttrTargSpec () {
  return (la.kind == _ident || keyword[la.kind]) && Peek(1).kind == _colon;
}

// ident ("," | "=" | ";")
bool IsFieldDecl () {
  int peek = Peek(1).kind;
  return la.kind == _ident && 
         (peek == _comma || peek == _assgn || peek == _scolon);
}

bool IsTypeCast () {
  if (la.kind != _lpar) { return false; }
  if (IsSimpleTypeCast()) { return true; }
  return GuessTypeCast();
}

// "(" typeKW ")"
bool IsSimpleTypeCast () {
	// assert: la.kind == _lpar
	scanner.ResetPeek();
	Token pt1 = scanner.Peek();
	Token pt2 = scanner.Peek();
	return typeKW[pt1.kind] && pt2.kind == _rpar;
}

// "(" Type ")" castFollower
bool GuessTypeCast () {
  // assert: la.kind == _lpar
  scanner.ResetPeek();
  Token pt = scanner.Peek();
  if (!IsType(ref pt)) {
    return false;
  }
  if (pt.kind != _rpar) {
    return false;
  }
  pt = scanner.Peek();
  return castFollower[pt.kind];
}

// "[" "assembly"
bool IsGlobalAttrTarget () {
  Token pt = Peek(1);
  return la.kind == _lbrack && pt.kind == _ident && "assembly".Equals(pt.val);
}

// "extern" "alias"
// where alias is an identifier, no keyword
bool IsExternAliasDirective () {
  return la.kind == _extern && "alias".Equals(Peek(1).val);
}

// true: anyToken"<"
// no whitespace between the token and the "<" allowed
// anything else will return false.
bool IsLtNoWs() {
  return (la.kind == _lt) && ((t.pos + t.val.Length) == la.pos);
}

bool IsNoSwitchLabelOrRBrace() {
  return (la.kind != _case && la.kind != _default && la.kind != _rbrace) ||
         (la.kind == _default && Peek(1).kind != _colon);
}

bool IsShift() {
  Token pt = Peek(1);
  return (la.kind == _ltlt) ||
         ( la.kind == _gt &&
           pt.kind == _gt &&
           (la.pos + la.val.Length == pt.pos)
         );
}

enum TypeKind {simple, array, pointer, @void}

[Flags]
enum Operator {
  plus   = 0x00000001, minus  = 0x00000002, not    = 0x00000004, tilde  = 0x00000008,
  inc    = 0x00000010, dec    = 0x00000020, @true  = 0x00000040, @false = 0x00000080,
  times  = 0x00000100, div    = 0x00000200, mod    = 0x00000400, and    = 0x00000800,
  or     = 0x00001000, xor    = 0x00002000, lshift = 0x00004000, rshift = 0x00008000,
  eq     = 0x00010000, neq    = 0x00020000, gt     = 0x00040000, lt     = 0x00080000,
  gte    = 0x00100000, lte    = 0x00200000,
  unary  = plus|minus|not|tilde|inc|dec|@true|@false,
  binary = plus|minus|times|div|mod|and|or|xor|lshift|rshift|eq|neq|gt|lt|gte|lte
}

/*------------------------- modifier handling -----------------------------*/

[Flags]
enum Modifier {
  @new      = 0x0001, @public = 0x0002, @protected= 0x0004, @internal = 0x0008,
  @private  = 0x0010, @unsafe = 0x0020, @static   = 0x0040, @readonly = 0x0080,
  @volatile = 0x0100, @virtual= 0x0200, @sealed   = 0x0400, @override = 0x0800,
  @abstract = 0x1000, @extern = 0x2000,
  
  /* sets of modifiers that can be attached to certain program elements    *
   * e.g., "constants" marks all modifiers that may be used with constants */
  none             = 0x0000,
  classes          = @new|@public|@protected|@internal|@private|@unsafe|@abstract|@sealed|@static,
  constants        = @new|@public|@protected|@internal|@private,
  fields           = @new|@public|@protected|@internal|@private|@unsafe|@static|@readonly|@volatile,
  propEvntMeths    = @new|@public|@protected|@internal|@private|@unsafe|@static|@virtual|@sealed|@override|@abstract|@extern,
  accessorsPossib1 = @private,
  accessorsPossib2 = @protected|@internal,
  indexers         = @new|@public|@protected|@internal|@private|@unsafe|@virtual|@sealed|@override|@abstract|@extern,
  operators        = @public|@unsafe|@static|@extern,
  operatorsMust    = @public|@static,
  constructors     = @public|@protected|@internal|@private|@unsafe|@extern,
  staticConstr     = @extern|@static,
  staticConstrMust = @static,
  nonClassTypes    = @new|@public|@protected|@internal|@private|@unsafe,
  destructors      = @extern|@unsafe,
  all              = 0x3fff
}

class Modifiers {
  private Modifier cur = Modifier.none;
  private Parser parser;
  
  public Modifiers(Parser parser) {
  	this.parser = parser;
  }
  
  public void Add (Modifier m) {
    if ((cur & m) == 0) cur |= m;
    else parser.Error("modifier " + m + " already defined");
  }
  
  public void Add (Modifiers m) { Add(m.cur); }

  public bool IsNone { get { return cur == Modifier.none; } }

  public void Check (Modifier allowed) {
    Modifier wrong = cur & (allowed ^ Modifier.all);
    if (wrong != Modifier.none)
      parser.Error("modifier(s) " + wrong + " not allowed here");
  }
  
  public void Check (Modifier allowEither, Modifier allowOr) {
    Modifier wrong = cur & ((allowEither|allowOr) ^ Modifier.all);
    if ((allowEither&allowOr) != Modifier.none) {
      parser.Error("modifiers providerd must not overlap");
    } else if (wrong != Modifier.none) {
      parser.Error("modifier(s) " + wrong + " not allowed here");
    } else if (((cur&allowEither) != Modifier.none) && ((cur&allowOr) != Modifier.none)) {
      parser.Error("modifier(s) may either be " + allowEither + " or " + allowOr);
    }
  }
  
  public void CheckMust (Modifier mustHave) {
    Modifier missing = (cur&mustHave)^mustHave;
    if (missing != Modifier.none) {
      parser.Error("modifier(s) " + missing + " must be applied here");
    }
  }
  
  public bool Has (Modifier mod) {
    return (cur&mod) == mod;
  }
}

/*
	C# Expert Functions
*/
bool IsDeclaration()
{
	return IsType(ref la) && Peek(1).kind == _ident;
}

/*
	Knowledge .NET Functions
*/
bool IsFullConceptDeclaration()
{
	return la.kind == _ident && Peek(1).kind == _lbrace;
}


/*------------------------------------------------------------------------*
 *----- SCANNER DESCRIPTION ----------------------------------------------*
 *------------------------------------------------------------------------*/


#line hidden

		public Parser(Scanner scanner) {
			this.scanner = scanner;
			errors = new Errors(scanner);
		}

		public Parser(System.IO.Stream str) {
			scanner = new Scanner(str);
			errors = new Errors(scanner);
		}
		
		public Parser(string source) {
			MemoryStream memIn = new MemoryStream();
			byte[] b=System.Text.Encoding.ASCII.GetBytes(source);
			memIn.Write(b,0,b.Length);
			memIn.Seek(0,0);
			this.scanner = new Scanner(memIn);
			errors = new Errors(scanner);
		}

		void SynErr (int n) {
			if (errDist >= minErrDist) errors.SynErr(la.line, la.col, n);
			errDist = 0;
		}

		public void SemErr (string msg) {
			if (errDist >= minErrDist) errors.Error(t.line, t.col, msg);
			errDist = 0;
		}
		
		void Get () {
			for (;;) {
				t = la;
				la = scanner.Scan();
				if (la.kind <= maxT) { ++errDist; break; }
				if (la.kind == 172) {

#line 694 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                         AddCCS(la.val); 
#line hidden

				}
				if (la.kind == 173) {

#line 695 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                         RemCCS(la.val); 
#line hidden

				}
				if (la.kind == 174) {

#line 696 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                         IfPragma(la.val); 
#line hidden

				}
				if (la.kind == 175) {

#line 697 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                         ElifOrElsePragma(); 
#line hidden

				}
				if (la.kind == 176) {

#line 698 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                         ElifOrElsePragma(); 
#line hidden

				}
				if (la.kind == 177) {
				}
				if (la.kind == 178) {
				}
				if (la.kind == 179) {
				}
				if (la.kind == 180) {
				}
				if (la.kind == 181) {
				}
				if (la.kind == 182) {
				}

				la = t;
			}
		}
		
		void Expect (int n) {
			if (la.kind==n) Get(); else { SynErr(n); }
		}
		
		bool StartOf (int s) {
			return set[s, la.kind];
		}
		
		void ExpectWeak (int n, int follow) {
			if (la.kind == n) Get();
			else {
				SynErr(n);
				while (!StartOf(follow)) Get();
			}
		}
		
		bool WeakSeparator (int n, int syFol, int repFol) {
			bool[] s = new bool[maxT+1];
			if (la.kind == n) { Get(); return true; }
			else if (StartOf(repFol)) return false;
			else {
				for (int i=0; i <= maxT; i++) {
					s[i] = set[syFol, i] || set[repFol, i] || set[0, i];
				}
				SynErr(n);
				while (!s[la.kind]) Get();
				return StartOf(syFol);
			}
		}
		
	void CS2() {

#line 719 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                    int begPos = la.pos; 
#line hidden

		while (
#line 720 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
       IsExternAliasDirective()
#line hidden
) {
			ExternAliasDirective();
		}
		while (la.kind == 78) {
			UsingDirective();
		}
		while (
#line 722 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
       IsGlobalAttrTarget()
#line hidden
) {
			GlobalAttributes();
		}
		while (StartOf(1)) {
			NamespaceMemberDeclaration();
		}

#line 724 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                   ExpComp.precedingCScode = new CScode(begPos, la.pos); 
#line hidden

		while (la.kind == 119) {
			Get();
			Expect(5);
			if (la.kind == 120) {
				Get();
				while (la.kind == 1 || la.kind == 159) {
					if (la.kind == 1) {
						KnowledgeConceptDeclaration();
					} else {
						KnowledgeDisjointDeclaration();
					}
				}
			}
			if (la.kind == 121) {
				Get();
				while (la.kind == 163 || la.kind == 164 || la.kind == 165) {
					KnowledgePropertyDeclaration();
				}
			}
			if (la.kind == 122) {
				Get();
				while (StartOf(2)) {
					KnowledgeIndividualDeclaration();
				}
			}
			Expect(123);
			if (la.kind == 5) {
				Get();
			}
		}
		Expect(124);
		while (la.kind == 136) {
			ExpertFrameDeclaration();
		}
	}

	void ExternAliasDirective() {
		Expect(28);
		Expect(1);

#line 754 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                   if (t.val != "alias") {
                                                                     Error("alias expected");
                                                                   }
                                                                
#line hidden

		Expect(1);
		Expect(114);
	}

	void UsingDirective() {
		Expect(78);
		if (
#line 763 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                IsAssignment()
#line hidden
) {
			Expect(1);
			Expect(85);
		}
		TypeName();
		Expect(114);
	}

	void GlobalAttributes() {
		Expect(97);
		Expect(1);

#line 1007 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                        if (t.val != "assembly") Error("global attribute target specifier \"assembly\" expected"); 
#line hidden

		Expect(86);
		Attribute();
		while (
#line 1008 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                           NotFinalComma()
#line hidden
) {
			Expect(87);
			Attribute();
		}
		if (la.kind == 87) {
			Get();
		}
		Expect(112);
	}

	void NamespaceMemberDeclaration() {

#line 767 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                   Modifiers m = new Modifiers(this); 
#line hidden

		if (la.kind == 45) {
			Get();
			Expect(1);
			while (la.kind == 90) {
				Get();
				Expect(1);
			}
			Expect(96);
			while (
#line 770 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
            IsExternAliasDirective()
#line hidden
) {
				ExternAliasDirective();
			}
			while (la.kind == 78) {
				UsingDirective();
			}
			while (StartOf(1)) {
				NamespaceMemberDeclaration();
			}
			Expect(111);
			if (la.kind == 114) {
				Get();
			}
		} else if (StartOf(3)) {
			while (la.kind == 97) {
				Attributes();
			}
			ModifierList(
#line 771 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                m
#line hidden
);
			TypeDeclaration(
#line 771 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                   m
#line hidden
);
		} else SynErr(172);
	}

	void KnowledgeConceptDeclaration() {
		if (
#line 1640 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
      !IsFullConceptDeclaration()
#line hidden
) {
			KnowledgeConceptSimpleDeclaration();
		} else if (la.kind == 1) {
			KnowledgeConceptFullDeclaration();
		} else SynErr(173);
	}

	void KnowledgeDisjointDeclaration() {
		Expect(159);
		Expect(1);
		while (la.kind == 87) {
			Get();
			Expect(1);
		}
		Expect(114);
	}

	void KnowledgePropertyDeclaration() {
		KnowledgePropertyModifier();
		if (la.kind == 160) {
			KnowledgeDatatypePropertyDeclaration();
		} else if (la.kind == 48) {
			KnowledgeObjectPropertyDeclaration();
		} else SynErr(174);
	}

	void KnowledgeIndividualDeclaration() {
		if (la.kind == 169) {
			Get();
			Expect(1);
			Expect(96);
			if (la.kind == 170) {
				KnowledgeAliasDefenition();
			}
		} else if (la.kind == 141) {
			KnowledgeIsADefenition();
		} else if (la.kind == 1 || la.kind == 111) {
			while (la.kind == 1) {
				KnowledgePropertyAssignment();
			}
			Expect(111);
		} else SynErr(175);
	}

	void ExpertFrameDeclaration() {
		Expect(136);
		if (la.kind == 16) {
			Get();

#line 1464 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                        ExpComp.curFr = la.val; ExpComp.addDataFrame(new DataFrame(la.val, DataFrame.FrameTypes.classFrame));    
#line hidden

			Expect(1);
			ExpertFrameClassBody();
		} else if (la.kind == 137) {
			Get();

#line 1467 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                          ExpComp.curFr = la.val; ExpComp.addDataFrame(new DataFrame(la.val, DataFrame.FrameTypes.instanceFrame)); 
#line hidden

			Expect(1);
			ExpertFrameInstanceBody();
		} else if (la.kind == 138) {
			Get();

#line 1470 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                         ExpComp.curFr = la.val; ExpComp.addRuleFrame(new RuleFrame(la.val)); 
#line hidden

			Expect(1);
			if (la.kind == 98) {
				ExpertRulesetParamList();
			}
			ExpertFrameRulesetBody();
		} else SynErr(176);
	}

	void TypeName() {
		Expect(1);
		if (la.kind == 91) {
			Get();
			Expect(1);
		}
		if (la.kind == 100) {
			TypeArgumentList();
		}
		while (la.kind == 90) {
			Get();
			Expect(1);
			if (la.kind == 100) {
				TypeArgumentList();
			}
		}
	}

	void Attributes() {
		Expect(97);
		if (
#line 1014 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
            IsAttrTargSpec()
#line hidden
) {
			if (la.kind == 1) {
				Get();
			} else if (StartOf(4)) {
				Keyword();
			} else SynErr(177);
			Expect(86);
		}
		Attribute();
		while (
#line 1015 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                  la.kind == _comma && Peek(1).kind != _rbrack
#line hidden
) {
			Expect(87);
			Attribute();
		}
		if (la.kind == 87) {
			Get();
		}
		Expect(112);
	}

	void ModifierList(
#line 1053 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
             Modifiers m
#line hidden
) {
		while (StartOf(5)) {
			switch (la.kind) {
			case 46: {
				Get();

#line 1056 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                      m.Add(Modifier.@new); 
#line hidden

				break;
			}
			case 55: {
				Get();

#line 1057 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                      m.Add(Modifier.@public); 
#line hidden

				break;
			}
			case 54: {
				Get();

#line 1058 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                      m.Add(Modifier.@protected); 
#line hidden

				break;
			}
			case 41: {
				Get();

#line 1059 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                      m.Add(Modifier.@internal); 
#line hidden

				break;
			}
			case 53: {
				Get();

#line 1060 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                      m.Add(Modifier.@private); 
#line hidden

				break;
			}
			case 76: {
				Get();

#line 1061 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                      m.Add(Modifier.@unsafe); 
#line hidden

				break;
			}
			case 64: {
				Get();

#line 1062 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                      m.Add(Modifier.@static); 
#line hidden

				break;
			}
			case 56: {
				Get();

#line 1063 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                      m.Add(Modifier.@readonly); 
#line hidden

				break;
			}
			case 81: {
				Get();

#line 1064 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                      m.Add(Modifier.@volatile); 
#line hidden

				break;
			}
			case 79: {
				Get();

#line 1065 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                      m.Add(Modifier.@virtual); 
#line hidden

				break;
			}
			case 60: {
				Get();

#line 1066 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                      m.Add(Modifier.@sealed); 
#line hidden

				break;
			}
			case 51: {
				Get();

#line 1067 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                      m.Add(Modifier.@override); 
#line hidden

				break;
			}
			case 6: {
				Get();

#line 1068 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                      m.Add(Modifier.@abstract); 
#line hidden

				break;
			}
			case 28: {
				Get();

#line 1069 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                      m.Add(Modifier.@extern); 
#line hidden

				break;
			}
			}
		}
	}

	void TypeDeclaration(
#line 774 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                Modifiers m
#line hidden
) {

#line 774 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                   TypeKind dummy; 
#line hidden

		if (StartOf(6)) {
			if (la.kind == 125) {
				Get();
			}
			if (la.kind == 16) {

#line 777 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                   m.Check(Modifier.classes); 
#line hidden

				Get();
				Expect(1);
				if (la.kind == 100) {
					TypeParameterList();
				}
				if (la.kind == 86) {
					ClassBase();
				}
				while (la.kind == 1) {
					TypeParameterConstraintsClause();
				}
				ClassBody();
				if (la.kind == 114) {
					Get();
				}
			} else if (la.kind == 66) {

#line 780 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                   m.Check(Modifier.nonClassTypes); 
#line hidden

				Get();
				Expect(1);
				if (la.kind == 100) {
					TypeParameterList();
				}
				if (la.kind == 86) {
					Get();
					TypeName();
					while (la.kind == 87) {
						Get();
						TypeName();
					}
				}
				while (la.kind == 1) {
					TypeParameterConstraintsClause();
				}
				StructBody();
				if (la.kind == 114) {
					Get();
				}
			} else if (la.kind == 40) {

#line 784 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                   m.Check(Modifier.nonClassTypes); 
#line hidden

				Get();
				Expect(1);
				if (la.kind == 100) {
					TypeParameterList();
				}
				if (la.kind == 86) {
					Get();
					TypeName();
					while (la.kind == 87) {
						Get();
						TypeName();
					}
				}
				while (la.kind == 1) {
					TypeParameterConstraintsClause();
				}
				Expect(96);
				while (StartOf(7)) {
					InterfaceMemberDeclaration();
				}
				Expect(111);
				if (la.kind == 114) {
					Get();
				}
			} else SynErr(178);
		} else if (la.kind == 25) {

#line 790 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                   m.Check(Modifier.nonClassTypes); 
#line hidden

			Get();
			Expect(1);
			if (la.kind == 86) {
				Get();
				IntegralType();
			}
			EnumBody();
			if (la.kind == 114) {
				Get();
			}
		} else if (la.kind == 21) {

#line 792 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                   m.Check(Modifier.nonClassTypes); 
#line hidden

			Get();
			Type(
#line 793 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                    out dummy, true
#line hidden
);
			Expect(1);
			if (la.kind == 100) {
				TypeParameterList();
			}
			Expect(98);
			if (StartOf(8)) {
				FormalParameterList();
			}
			Expect(113);
			while (la.kind == 1) {
				TypeParameterConstraintsClause();
			}
			Expect(114);
		} else SynErr(179);
	}

	void TypeParameterList() {
		Expect(100);
		while (la.kind == 97) {
			Attributes();
		}
		Expect(1);
		while (la.kind == 87) {
			Get();
			while (la.kind == 97) {
				Attributes();
			}
			Expect(1);
		}
		Expect(93);
	}

	void ClassBase() {
		Expect(86);
		ClassType();
		while (la.kind == 87) {
			Get();
			TypeName();
		}
	}

	void TypeParameterConstraintsClause() {
		Expect(1);

#line 1450 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                                  if (t.val != "where") {
                                                                                    Error("type parameter constraints clause must start with: where");
                                                                                  }
                                                                               
#line hidden

		Expect(1);
		Expect(86);
		if (StartOf(9)) {
			if (la.kind == 16) {
				Get();
			} else if (la.kind == 66) {
				Get();
			} else if (la.kind == 48) {
				Get();
			} else if (la.kind == 65) {
				Get();
			} else {
				TypeName();
			}
			while (
#line 1455 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                  la.kind == _comma && Peek(1).kind != _new
#line hidden
) {
				Expect(87);
				TypeName();
			}
			if (la.kind == 87) {
				Get();
				Expect(46);
				Expect(98);
				Expect(113);
			}
		} else if (la.kind == 46) {
			Get();
			Expect(98);
			Expect(113);
		} else SynErr(180);
	}

	void ClassBody() {
		Expect(96);
		while (StartOf(10)) {
			while (la.kind == 97) {
				Attributes();
			}

#line 806 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                                 Modifiers m = new Modifiers(this); 
#line hidden

			ModifierList(
#line 807 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                     m
#line hidden
);
			ClassMemberDeclaration(
#line 808 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                               m
#line hidden
);
		}
		Expect(111);
	}

	void StructBody() {
		Expect(96);
		while (StartOf(11)) {
			while (la.kind == 97) {
				Attributes();
			}

#line 815 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                                 Modifiers m = new Modifiers(this); 
#line hidden

			ModifierList(
#line 816 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                     m
#line hidden
);
			StructMemberDeclaration(
#line 817 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                m
#line hidden
);
		}
		Expect(111);
	}

	void InterfaceMemberDeclaration() {

#line 898 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                                 Modifiers m = new Modifiers(this);
                                                                                 TypeKind dummy;
                                                                              
#line hidden

		while (la.kind == 97) {
			Attributes();
		}
		if (la.kind == 46) {
			Get();
		}
		if (StartOf(12)) {
			Type(
#line 903 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
         out dummy, true
#line hidden
);
			if (la.kind == 1) {
				Get();
				if (la.kind == 98 || la.kind == 100) {
					if (la.kind == 100) {
						TypeParameterList();
					}
					Expect(98);
					if (StartOf(8)) {
						FormalParameterList();
					}
					Expect(113);
					while (la.kind == 1) {
						TypeParameterConstraintsClause();
					}
					Expect(114);
				} else if (la.kind == 96) {
					Get();
					InterfaceAccessors(
#line 905 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                          m
#line hidden
);
					Expect(111);
				} else SynErr(181);
			} else if (la.kind == 68) {
				Get();
				Expect(97);
				FormalParameterList();
				Expect(112);
				Expect(96);
				InterfaceAccessors(
#line 907 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                m
#line hidden
);
				Expect(111);
			} else SynErr(182);
		} else if (la.kind == 26) {
			Get();
			Type(
#line 909 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                 out dummy, false
#line hidden
);
			Expect(1);
			Expect(114);
		} else SynErr(183);
	}

	void IntegralType() {
		switch (la.kind) {
		case 59: {
			Get();
			break;
		}
		case 11: {
			Get();
			break;
		}
		case 61: {
			Get();
			break;
		}
		case 77: {
			Get();
			break;
		}
		case 39: {
			Get();
			break;
		}
		case 73: {
			Get();
			break;
		}
		case 44: {
			Get();
			break;
		}
		case 74: {
			Get();
			break;
		}
		case 14: {
			Get();
			break;
		}
		default: SynErr(184); break;
		}
	}

	void EnumBody() {
		Expect(96);
		if (la.kind == 1 || la.kind == 97) {
			EnumMemberDeclaration();
			while (
#line 824 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                   NotFinalComma()
#line hidden
) {
				Expect(87);
				EnumMemberDeclaration();
			}
			if (la.kind == 87) {
				Get();
			}
		}
		Expect(111);
	}

	void Type(
#line 1080 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
     out TypeKind type, bool voidAllowed
#line hidden
) {

#line 1080 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                        type = TypeKind.simple; 
#line hidden

		if (StartOf(13)) {
			PrimitiveType();
		} else if (la.kind == 1 || la.kind == 48 || la.kind == 65) {
			ClassType();
		} else if (la.kind == 80) {
			Get();

#line 1084 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                        type = TypeKind.@void; 
#line hidden

		} else SynErr(185);
		if (la.kind == 110) {
			Get();

#line 1086 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                        if (type == TypeKind.@void) { Error("Unexpected token ?, void must not be nullable."); } 
#line hidden

		}
		PointerOrArray(
#line 1088 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                 ref type
#line hidden
);

#line 1088 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                        if (type == TypeKind.@void && !voidAllowed) { Error("type expected, void found, maybe you mean void*"); } 
#line hidden

	}

	void FormalParameterList() {

#line 943 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                        TypeKind type; 
#line hidden

		while (la.kind == 97) {
			Attributes();
		}
		if (StartOf(14)) {
			if (la.kind == 50 || la.kind == 57) {
				if (la.kind == 57) {
					Get();
				} else {
					Get();
				}
			}
			Type(
#line 946 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                           out type, false
#line hidden
);
			Expect(1);
			if (la.kind == 87) {
				Get();
				FormalParameterList();
			}
		} else if (la.kind == 52) {
			Get();
			Type(
#line 948 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                  out type, false
#line hidden
);

#line 948 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                        if (type != TypeKind.array) { Error("params argument must be an array"); } 
#line hidden

			Expect(1);
		} else SynErr(186);
	}

	void ClassType() {
		if (la.kind == 1) {
			TypeName();
		} else if (la.kind == 48 || la.kind == 65) {
			InternalClassType();
		} else SynErr(187);
	}

	void ClassMemberDeclaration(
#line 827 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                       Modifiers m
#line hidden
) {
		if (StartOf(15)) {
			StructMemberDeclaration(
#line 829 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                          m
#line hidden
);
		} else if (la.kind == 115) {
			Get();
			Expect(1);
			Expect(98);
			Expect(113);
			if (la.kind == 96) {
				Block();
			} else if (la.kind == 114) {
				Get();
			} else SynErr(188);
		} else SynErr(189);
	}

	void StructMemberDeclaration(
#line 833 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                        Modifiers m
#line hidden
) {

#line 833 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                                 TypeKind type; Operator op; 
#line hidden

		if (la.kind == 17) {

#line 835 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                                 m.Check(Modifier.constants); 
#line hidden

			Get();
			Type(
#line 836 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                 out type, false
#line hidden
);
			Expect(1);
			Expect(85);
			Expression();
			while (la.kind == 87) {
				Get();
				Expect(1);
				Expect(85);
				Expression();
			}
			Expect(114);
		} else if (la.kind == 26) {

#line 838 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                                 m.Check(Modifier.propEvntMeths); 
#line hidden

			Get();
			Type(
#line 839 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                 out type, false
#line hidden
);
			if (
#line 840 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
          IsFieldDecl()
#line hidden
) {
				VariableDeclarators();
				Expect(114);
			} else if (la.kind == 1) {
				TypeName();
				Expect(96);
				EventAccessorDeclarations();
				Expect(111);
			} else SynErr(190);
		} else if (
#line 844 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
        la.kind == _ident && Peek(1).kind == _lpar
#line hidden
) {

#line 844 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                                 m.Check(Modifier.constructors|Modifier.staticConstr); 
#line hidden

			Expect(1);
			Expect(98);
			if (StartOf(8)) {

#line 845 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                                 m.Check(Modifier.constructors); 
#line hidden

				FormalParameterList();
			}
			Expect(113);
			if (la.kind == 86) {

#line 847 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                                 m.Check(Modifier.constructors); 
#line hidden

				Get();
				if (la.kind == 8) {
					Get();
				} else if (la.kind == 68) {
					Get();
				} else SynErr(191);
				Expect(98);
				if (StartOf(16)) {
					Argument();
					while (la.kind == 87) {
						Get();
						Argument();
					}
				}
				Expect(113);
			}
			if (la.kind == 96) {
				Block();
			} else if (la.kind == 114) {
				Get();
			} else SynErr(192);
		} else if (StartOf(12)) {
			Type(
#line 851 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
         out type, true
#line hidden
);
			if (la.kind == 49) {

#line 852 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                               m.Check(Modifier.operators);
                                                                               m.CheckMust(Modifier.operatorsMust);
                                                                               if (type == TypeKind.@void) { Error("operator not allowed on void"); } 
                                                                            
#line hidden

				Get();
				OverloadableOp(
#line 856 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                out op
#line hidden
);
				Expect(98);
				Type(
#line 856 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                 out type, false
#line hidden
);
				Expect(1);
				if (la.kind == 87) {
					Get();
					Type(
#line 857 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                 out type, false
#line hidden
);
					Expect(1);

#line 857 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                              if ((op & Operator.binary) == 0) Error("too many operands for unary operator"); 
#line hidden

				} else if (la.kind == 113) {

#line 858 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                               if ((op & Operator.unary) == 0) Error("too few operands for binary operator"); 
#line hidden

				} else SynErr(193);
				Expect(113);
				if (la.kind == 96) {
					Block();
				} else if (la.kind == 114) {
					Get();
				} else SynErr(194);
			} else if (
#line 862 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
          IsFieldDecl()
#line hidden
) {

#line 862 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                               m.Check(Modifier.fields);
                                                                               if (type == TypeKind.@void) { Error("field type must not be void"); } 
                                                                            
#line hidden

				VariableDeclarators();
				Expect(114);
			} else if (la.kind == 1) {
				NonGenericTypeName();
				if (la.kind == 96) {

#line 868 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                                  m.Check(Modifier.propEvntMeths);
                                                                                  if (type == TypeKind.@void) { Error("property type must not be void"); }
                                                                               
#line hidden

					Get();
					AccessorDeclarations(
#line 871 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                 m
#line hidden
);
					Expect(111);
				} else if (la.kind == 90) {

#line 872 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                                  m.Check(Modifier.indexers);
                                                                                  if (type == TypeKind.@void) { Error("indexer type must not be void"); } 
                                                                               
#line hidden

					Get();
					Expect(68);
					Expect(97);
					FormalParameterList();
					Expect(112);
					Expect(96);
					AccessorDeclarations(
#line 875 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                        m
#line hidden
);
					Expect(111);
				} else if (la.kind == 98 || la.kind == 100) {

#line 876 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                                  m.Check(Modifier.propEvntMeths); 
#line hidden

					if (la.kind == 100) {
						TypeParameterList();
					}
					Expect(98);
					if (StartOf(8)) {
						FormalParameterList();
					}
					Expect(113);
					while (la.kind == 1) {
						TypeParameterConstraintsClause();
					}
					if (la.kind == 96) {
						Block();
					} else if (la.kind == 114) {
						Get();
					} else SynErr(195);
				} else SynErr(196);
			} else if (la.kind == 68) {

#line 882 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                                  m.Check(Modifier.indexers);
                                                                                  if (type == TypeKind.@void) { Error("indexer type must not be void"); }
                                                                               
#line hidden

				Get();
				Expect(97);
				FormalParameterList();
				Expect(112);
				Expect(96);
				AccessorDeclarations(
#line 885 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                    m
#line hidden
);
				Expect(111);
			} else SynErr(197);
		} else if (la.kind == 27 || la.kind == 37) {

#line 888 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                                    m.Check(Modifier.operators);
                                                                                    m.CheckMust(Modifier.operatorsMust);
                                                                                 
#line hidden

			if (la.kind == 37) {
				Get();
			} else {
				Get();
			}
			Expect(49);
			Type(
#line 891 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                out type, false
#line hidden
);

#line 891 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                                    if (type == TypeKind.@void) { Error("cast type must not be void"); } 
#line hidden

			Expect(98);
			Type(
#line 892 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
             out type, false
#line hidden
);
			Expect(1);
			Expect(113);
			if (la.kind == 96) {
				Block();
			} else if (la.kind == 114) {
				Get();
			} else SynErr(198);
		} else if (StartOf(17)) {
			TypeDeclaration(
#line 894 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                    m
#line hidden
);
		} else SynErr(199);
	}

	void EnumMemberDeclaration() {
		while (la.kind == 97) {
			Attributes();
		}
		Expect(1);
		if (la.kind == 85) {
			Get();
			Expression();
		}
	}

	void Block() {
		Expect(96);
		while (StartOf(18)) {
			Statement();
		}
		Expect(111);
	}

	void Expression() {
		Unary();
		if (
#line 1271 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
        assgnOps[la.kind] || (la.kind == _gt && Peek(1).kind == _gteq)
#line hidden
) {
			AssignmentOperator();
			Expression();
		} else if (StartOf(19)) {
			NullCoalescingExpr();
			if (la.kind == 110) {
				Get();
				Expression();
				Expect(86);
				Expression();
			}
		} else SynErr(200);
	}

	void VariableDeclarators() {
		Expect(1);
		if (la.kind == 85) {
			Get();
			VariableInitializer();
		}
		while (la.kind == 87) {
			Get();
			Expect(1);
			if (la.kind == 85) {
				Get();
				VariableInitializer();
			}
		}
	}

	void EventAccessorDeclarations() {

#line 975 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                        bool addFound = false, remFound = false; 
#line hidden

		while (la.kind == 97) {
			Attributes();
		}
		if (
#line 977 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
        "add".Equals(la.val)
#line hidden
) {
			Expect(1);

#line 977 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                        addFound = true; 
#line hidden

		} else if (
#line 978 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
        "remove".Equals(la.val)
#line hidden
) {
			Expect(1);

#line 978 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                        remFound = true; 
#line hidden

		} else if (la.kind == 1) {
			Get();

#line 979 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                        Error("add or remove expected"); 
#line hidden

		} else SynErr(201);
		Block();
		if (la.kind == 1 || la.kind == 97) {
			while (la.kind == 97) {
				Attributes();
			}
			if (
#line 983 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
          "add".Equals(la.val)
#line hidden
) {
				Expect(1);

#line 983 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                        if (addFound) Error("add already declared");    
#line hidden

			} else if (
#line 984 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
          "remove".Equals(la.val)
#line hidden
) {
				Expect(1);

#line 984 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                        if (remFound) Error("remove already declared"); 
#line hidden

			} else if (la.kind == 1) {
				Get();

#line 985 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                        Error("add or remove expected"); 
#line hidden

			} else SynErr(202);
			Block();
		}
	}

	void Argument() {
		if (la.kind == 50 || la.kind == 57) {
			if (la.kind == 57) {
				Get();
			} else {
				Get();
			}
		}
		Expression();
	}

	void OverloadableOp(
#line 1408 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
               out Operator op
#line hidden
) {

#line 1408 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                                  op = Operator.plus; 
#line hidden

		switch (la.kind) {
		case 108: {
			Get();
			break;
		}
		case 102: {
			Get();

#line 1412 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                                  op = Operator.minus; 
#line hidden

			break;
		}
		case 106: {
			Get();

#line 1413 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                                  op = Operator.not; 
#line hidden

			break;
		}
		case 115: {
			Get();

#line 1414 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                                  op = Operator.tilde; 
#line hidden

			break;
		}
		case 95: {
			Get();

#line 1415 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                                  op = Operator.inc; 
#line hidden

			break;
		}
		case 88: {
			Get();

#line 1416 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                                  op = Operator.dec; 
#line hidden

			break;
		}
		case 70: {
			Get();

#line 1417 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                                  op = Operator.@true; 
#line hidden

			break;
		}
		case 29: {
			Get();

#line 1418 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                                  op = Operator.@false; 
#line hidden

			break;
		}
		case 116: {
			Get();

#line 1420 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                                  op = Operator.times; 
#line hidden

			break;
		}
		case 133: {
			Get();

#line 1421 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                                  op = Operator.div; 
#line hidden

			break;
		}
		case 134: {
			Get();

#line 1422 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                                  op = Operator.mod; 
#line hidden

			break;
		}
		case 83: {
			Get();

#line 1423 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                                  op = Operator.and; 
#line hidden

			break;
		}
		case 130: {
			Get();

#line 1424 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                                  op = Operator.or; 
#line hidden

			break;
		}
		case 131: {
			Get();

#line 1425 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                                  op = Operator.xor; 
#line hidden

			break;
		}
		case 101: {
			Get();

#line 1426 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                                  op = Operator.lshift; 
#line hidden

			break;
		}
		case 92: {
			Get();

#line 1427 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                                  op = Operator.eq; 
#line hidden

			break;
		}
		case 105: {
			Get();

#line 1428 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                                  op = Operator.neq; 
#line hidden

			break;
		}
		case 93: {
			Get();

#line 1429 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                                  op = Operator.gt; 
#line hidden

			if (la.kind == 93) {

#line 1430 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                                  if (la.pos > t.pos+1) Error("no whitespace allowed in right shift operator"); 
#line hidden

				Get();

#line 1431 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                                  op = Operator.rshift; 
#line hidden

			}
			break;
		}
		case 100: {
			Get();

#line 1433 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                                  op = Operator.lt; 
#line hidden

			break;
		}
		case 94: {
			Get();

#line 1434 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                                  op = Operator.gte; 
#line hidden

			break;
		}
		case 132: {
			Get();

#line 1435 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                                  op = Operator.lte; 
#line hidden

			break;
		}
		default: SynErr(203); break;
		}
	}

	void NonGenericTypeName() {
		Expect(1);
		if (la.kind == 91) {
			Get();
			Expect(1);
		}
		while (
#line 1140 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
        la.kind == _dot && Peek(1).kind == _ident
#line hidden
) {
			Expect(90);
			Expect(1);
		}
	}

	void AccessorDeclarations(
#line 958 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                     Modifiers m
#line hidden
) {

#line 958 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                        Modifiers am = new Modifiers(this);
                                                                        bool getFound = false, setFound = false;
                                                                     
#line hidden

		while (la.kind == 97) {
			Attributes();
		}
		ModifierList(
#line 961 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                              am
#line hidden
);

#line 961 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                        am.Check(Modifier.accessorsPossib1, Modifier.accessorsPossib2); 
#line hidden

		if (
#line 962 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
        "get".Equals(la.val)
#line hidden
) {
			Expect(1);

#line 962 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                        getFound = true; 
#line hidden

		} else if (
#line 963 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
        "set".Equals(la.val)
#line hidden
) {
			Expect(1);

#line 963 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                        setFound = true; 
#line hidden

		} else if (la.kind == 1) {
			Get();

#line 964 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                        Error("set or get expected"); 
#line hidden

		} else SynErr(204);
		if (la.kind == 96) {
			Block();
		} else if (la.kind == 114) {
			Get();
		} else SynErr(205);
		if (StartOf(20)) {

#line 966 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                        am = new Modifiers(this); 
#line hidden

			while (la.kind == 97) {
				Attributes();
			}
			ModifierList(
#line 967 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                am
#line hidden
);

#line 967 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                        am.Check(Modifier.accessorsPossib1, Modifier.accessorsPossib2); 
#line hidden

			if (
#line 968 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
          "get".Equals(la.val)
#line hidden
) {
				Expect(1);

#line 968 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                        if (getFound) Error("get already declared");  
#line hidden

			} else if (
#line 969 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
          "set".Equals(la.val)
#line hidden
) {
				Expect(1);

#line 969 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                        if (setFound) Error("set already declared");  
#line hidden

			} else if (la.kind == 1) {
				Get();

#line 970 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                        Error("set or get expected"); 
#line hidden

			} else SynErr(206);
			if (la.kind == 96) {
				Block();
			} else if (la.kind == 114) {
				Get();
			} else SynErr(207);
		}
	}

	void InterfaceAccessors(
#line 990 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                   Modifiers m
#line hidden
) {

#line 990 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                        bool getFound = false, setFound = false; 
#line hidden

		while (la.kind == 97) {
			Attributes();
		}
		if (
#line 992 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
        "get".Equals(la.val)
#line hidden
) {
			Expect(1);

#line 992 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                        getFound = true; 
#line hidden

		} else if (
#line 993 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
        "set".Equals(la.val)
#line hidden
) {
			Expect(1);

#line 993 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                        setFound = true; 
#line hidden

		} else if (la.kind == 1) {
			Get();

#line 994 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                        Error("set or get expected"); 
#line hidden

		} else SynErr(208);
		Expect(114);
		if (la.kind == 1 || la.kind == 97) {
			while (la.kind == 97) {
				Attributes();
			}
			if (
#line 998 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
          "get".Equals(la.val)
#line hidden
) {
				Expect(1);

#line 998 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                        if (getFound) Error("get already declared");  
#line hidden

			} else if (
#line 999 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
          "set".Equals(la.val)
#line hidden
) {
				Expect(1);

#line 999 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                        if (setFound) Error("set already declared");  
#line hidden

			} else if (la.kind == 1) {
				Get();

#line 1000 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                        Error("set or get expected"); 
#line hidden

			} else SynErr(209);
			Expect(114);
		}
	}

	void LocalVariableDeclaration() {

#line 918 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                                   TypeKind dummy; 
#line hidden

		Type(
#line 920 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
       out dummy, false
#line hidden
);
		LocalVariableDeclarator();
		while (la.kind == 87) {
			Get();
			LocalVariableDeclarator();
		}
	}

	void LocalVariableDeclarator() {

#line 924 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                                   TypeKind dummy; 
#line hidden

		Expect(1);
		if (la.kind == 85) {
			Get();
			if (StartOf(21)) {
				VariableInitializer();
			} else if (la.kind == 63) {
				Get();
				Type(
#line 929 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                      out dummy, false
#line hidden
);
				Expect(97);
				Expression();
				Expect(112);
			} else SynErr(210);
		}
	}

	void VariableInitializer() {
		if (StartOf(22)) {
			Expression();
		} else if (la.kind == 96) {
			ArrayInitializer();
		} else SynErr(211);
	}

	void ArrayInitializer() {
		Expect(96);
		if (StartOf(21)) {
			VariableInitializer();
			while (
#line 940 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                 NotFinalComma()
#line hidden
) {
				Expect(87);
				VariableInitializer();
			}
			if (la.kind == 87) {
				Get();
			}
		}
		Expect(111);
	}

	void Attribute() {
		TypeName();
		if (la.kind == 98) {
			AttributeArguments();
		}
	}

	void Keyword() {
		switch (la.kind) {
		case 6: {
			Get();
			break;
		}
		case 7: {
			Get();
			break;
		}
		case 8: {
			Get();
			break;
		}
		case 9: {
			Get();
			break;
		}
		case 10: {
			Get();
			break;
		}
		case 11: {
			Get();
			break;
		}
		case 12: {
			Get();
			break;
		}
		case 13: {
			Get();
			break;
		}
		case 14: {
			Get();
			break;
		}
		case 15: {
			Get();
			break;
		}
		case 16: {
			Get();
			break;
		}
		case 17: {
			Get();
			break;
		}
		case 18: {
			Get();
			break;
		}
		case 19: {
			Get();
			break;
		}
		case 20: {
			Get();
			break;
		}
		case 21: {
			Get();
			break;
		}
		case 22: {
			Get();
			break;
		}
		case 23: {
			Get();
			break;
		}
		case 24: {
			Get();
			break;
		}
		case 25: {
			Get();
			break;
		}
		case 26: {
			Get();
			break;
		}
		case 27: {
			Get();
			break;
		}
		case 28: {
			Get();
			break;
		}
		case 29: {
			Get();
			break;
		}
		case 30: {
			Get();
			break;
		}
		case 31: {
			Get();
			break;
		}
		case 32: {
			Get();
			break;
		}
		case 33: {
			Get();
			break;
		}
		case 34: {
			Get();
			break;
		}
		case 35: {
			Get();
			break;
		}
		case 36: {
			Get();
			break;
		}
		case 37: {
			Get();
			break;
		}
		case 38: {
			Get();
			break;
		}
		case 39: {
			Get();
			break;
		}
		case 40: {
			Get();
			break;
		}
		case 41: {
			Get();
			break;
		}
		case 42: {
			Get();
			break;
		}
		case 43: {
			Get();
			break;
		}
		case 44: {
			Get();
			break;
		}
		case 45: {
			Get();
			break;
		}
		case 46: {
			Get();
			break;
		}
		case 47: {
			Get();
			break;
		}
		case 48: {
			Get();
			break;
		}
		case 49: {
			Get();
			break;
		}
		case 50: {
			Get();
			break;
		}
		case 51: {
			Get();
			break;
		}
		case 52: {
			Get();
			break;
		}
		case 53: {
			Get();
			break;
		}
		case 54: {
			Get();
			break;
		}
		case 55: {
			Get();
			break;
		}
		case 56: {
			Get();
			break;
		}
		case 57: {
			Get();
			break;
		}
		case 58: {
			Get();
			break;
		}
		case 59: {
			Get();
			break;
		}
		case 60: {
			Get();
			break;
		}
		case 61: {
			Get();
			break;
		}
		case 62: {
			Get();
			break;
		}
		case 63: {
			Get();
			break;
		}
		case 64: {
			Get();
			break;
		}
		case 65: {
			Get();
			break;
		}
		case 66: {
			Get();
			break;
		}
		case 67: {
			Get();
			break;
		}
		case 68: {
			Get();
			break;
		}
		case 69: {
			Get();
			break;
		}
		case 70: {
			Get();
			break;
		}
		case 71: {
			Get();
			break;
		}
		case 72: {
			Get();
			break;
		}
		case 73: {
			Get();
			break;
		}
		case 74: {
			Get();
			break;
		}
		case 75: {
			Get();
			break;
		}
		case 76: {
			Get();
			break;
		}
		case 77: {
			Get();
			break;
		}
		case 78: {
			Get();
			break;
		}
		case 79: {
			Get();
			break;
		}
		case 80: {
			Get();
			break;
		}
		case 81: {
			Get();
			break;
		}
		case 82: {
			Get();
			break;
		}
		default: SynErr(212); break;
		}
	}

	void AttributeArguments() {

#line 1039 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                          bool nameFound = false; 
#line hidden

		Expect(98);
		if (StartOf(22)) {
			if (
#line 1041 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
              IsAssignment()
#line hidden
) {

#line 1041 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                          nameFound = true; 
#line hidden

				Expect(1);
				Expect(85);
			}
			Expression();
			while (la.kind == 87) {
				Get();
				if (
#line 1044 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                    IsAssignment()
#line hidden
) {

#line 1044 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                          nameFound = true; 
#line hidden

					Expect(1);
					Expect(85);
				} else if (StartOf(22)) {

#line 1046 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                          if (nameFound) Error("no positional argument after named arguments"); 
#line hidden

				} else SynErr(213);
				Expression();
			}
		}
		Expect(113);
	}

	void PrimitiveType() {
		if (StartOf(23)) {
			IntegralType();
		} else if (la.kind == 32) {
			Get();
		} else if (la.kind == 23) {
			Get();
		} else if (la.kind == 19) {
			Get();
		} else if (la.kind == 9) {
			Get();
		} else SynErr(214);
	}

	void PointerOrArray(
#line 1109 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
               ref TypeKind type
#line hidden
) {
		while (
#line 1111 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
        IsPointerOrDims()
#line hidden
) {
			if (la.kind == 116) {
				Get();

#line 1112 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                    type = TypeKind.pointer; 
#line hidden

			} else if (la.kind == 97) {
				Get();
				while (la.kind == 87) {
					Get();
				}
				Expect(112);

#line 1113 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                    type = TypeKind.array; 
#line hidden

			} else SynErr(215);
		}
	}

	void ResolvedType() {

#line 1091 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                        TypeKind type = TypeKind.simple; 
#line hidden

		if (StartOf(13)) {
			PrimitiveType();
		} else if (la.kind == 48) {
			Get();
		} else if (la.kind == 65) {
			Get();
		} else if (la.kind == 1) {
			Get();
			if (la.kind == 91) {
				Get();
				Expect(1);
			}
			if (
#line 1098 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                               IsGeneric()
#line hidden
) {
				TypeArgumentList();
			}
			while (la.kind == 90) {
				Get();
				Expect(1);
				if (
#line 1100 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                      IsGeneric()
#line hidden
) {
					TypeArgumentList();
				}
			}
		} else if (la.kind == 80) {
			Get();

#line 1104 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                        type = TypeKind.@void; 
#line hidden

		} else SynErr(216);
		PointerOrArray(
#line 1106 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                 ref type
#line hidden
);

#line 1106 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                        if (type == TypeKind.@void) Error("type expected, void found, maybe you mean void*"); 
#line hidden

	}

	void TypeArgumentList() {

#line 1443 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                                  TypeKind dummy; 
#line hidden

		Expect(100);
		Type(
#line 1445 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
           out dummy, false
#line hidden
);
		while (la.kind == 87) {
			Get();
			Type(
#line 1445 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                        out dummy, false
#line hidden
);
		}
		Expect(93);
	}

	void InternalClassType() {
		if (la.kind == 48) {
			Get();
		} else if (la.kind == 65) {
			Get();
		} else SynErr(217);
	}

	void Statement() {

#line 1157 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                                  TypeKind dummy; 
#line hidden

		if (
#line 1159 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
      la.kind == _ident && Peek(1).kind == _colon
#line hidden
) {
			Expect(1);
			Expect(86);
			Statement();
		} else if (la.kind == 17) {
			Get();
			Type(
#line 1160 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                 out dummy, false
#line hidden
);
			Expect(1);
			Expect(85);
			Expression();
			while (la.kind == 87) {
				Get();
				Expect(1);
				Expect(85);
				Expression();
			}
			Expect(114);
		} else if (
#line 1162 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
        IsLocalVarDecl()
#line hidden
) {
			LocalVariableDeclaration();
			Expect(114);
		} else if (StartOf(24)) {
			EmbeddedStatement();
		} else SynErr(218);
	}

	void EmbeddedStatement() {

#line 1166 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                                  TypeKind type; 
#line hidden

		if (la.kind == 96) {
			Block();
		} else if (la.kind == 114) {
			Get();
		} else if (
#line 1170 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
        la.kind == _checked && Peek(1).kind == _lbrace
#line hidden
) {
			Expect(15);
			Block();
		} else if (
#line 1171 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
        la.kind == _unchecked && Peek(1).kind == _lbrace
#line hidden
) {
			Expect(75);
			Block();
		} else if (StartOf(22)) {
			StatementExpression();
			Expect(114);
		} else if (la.kind == 36) {
			Get();
			Expect(98);
			Expression();
			Expect(113);
			EmbeddedStatement();
			if (la.kind == 24) {
				Get();
				EmbeddedStatement();
			}
		} else if (la.kind == 67) {
			Get();
			Expect(98);
			Expression();
			Expect(113);
			Expect(96);
			while (la.kind == 12 || la.kind == 20) {
				SwitchSection();
			}
			Expect(111);
		} else if (la.kind == 82) {
			Get();
			Expect(98);
			Expression();
			Expect(113);
			EmbeddedStatement();
		} else if (la.kind == 22) {
			Get();
			EmbeddedStatement();
			Expect(82);
			Expect(98);
			Expression();
			Expect(113);
			Expect(114);
		} else if (la.kind == 33) {
			Get();
			Expect(98);
			if (StartOf(25)) {
				ForInitializer();
			}
			Expect(114);
			if (StartOf(22)) {
				Expression();
			}
			Expect(114);
			if (StartOf(22)) {
				ForIterator();
			}
			Expect(113);
			EmbeddedStatement();
		} else if (la.kind == 34) {
			Get();
			Expect(98);
			Type(
#line 1179 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                       out type, false
#line hidden
);
			Expect(1);
			Expect(38);
			Expression();
			Expect(113);
			EmbeddedStatement();
		} else if (la.kind == 10) {
			Get();
			Expect(114);
		} else if (la.kind == 18) {
			Get();
			Expect(114);
		} else if (la.kind == 35) {
			Get();
			if (la.kind == 1) {
				Get();
			} else if (la.kind == 12) {
				Get();
				Expression();
			} else if (la.kind == 20) {
				Get();
			} else SynErr(219);
			Expect(114);
		} else if (la.kind == 58) {
			Get();
			if (StartOf(22)) {
				Expression();
			}
			Expect(114);
		} else if (la.kind == 69) {
			Get();
			if (StartOf(22)) {
				Expression();
			}
			Expect(114);
		} else if (la.kind == 71) {
			Get();
			Block();
			if (la.kind == 13) {
				CatchClauses();
				if (la.kind == 30) {
					Get();
					Block();
				}
			} else if (la.kind == 30) {
				Get();
				Block();
			} else SynErr(220);
		} else if (la.kind == 43) {
			Get();
			Expect(98);
			Expression();
			Expect(113);
			EmbeddedStatement();
		} else if (la.kind == 78) {
			Get();
			Expect(98);
			ResourceAcquisition();
			Expect(113);
			EmbeddedStatement();
		} else if (la.kind == 126) {
			Get();
			if (la.kind == 58) {
				Get();
				Expression();
			} else if (la.kind == 10) {
				Get();
			} else SynErr(221);
			Expect(114);
		} else if (la.kind == 76) {
			Get();
			Block();
		} else if (la.kind == 31) {
			Get();
			Expect(98);
			Type(
#line 1191 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                     out type, false
#line hidden
);

#line 1191 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                                         if (type != TypeKind.pointer) Error("can only fix pointer types"); 
#line hidden

			Expect(1);
			Expect(85);
			Expression();
			while (la.kind == 87) {
				Get();
				Expect(1);
				Expect(85);
				Expression();
			}
			Expect(113);
			EmbeddedStatement();
		} else SynErr(222);
	}

	void StatementExpression() {

#line 1201 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                    bool isAssignment = assnStartOp[la.kind] || IsTypeCast(); 
#line hidden

		Unary();
		if (StartOf(26)) {
			AssignmentOperator();
			Expression();
		} else if (la.kind == 87 || la.kind == 113 || la.kind == 114) {

#line 1205 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                    if (isAssignment) Error("error in assignment."); 
#line hidden

		} else SynErr(223);
	}

	void SwitchSection() {
		SwitchLabel();
		while (
#line 1227 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                    la.kind == _case || (la.kind == _default && Peek(1).kind == _colon)
#line hidden
) {
			SwitchLabel();
		}
		Statement();
		while (
#line 1228 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                  IsNoSwitchLabelOrRBrace()
#line hidden
) {
			Statement();
		}
	}

	void ForInitializer() {
		if (
#line 1239 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
      IsLocalVarDecl()
#line hidden
) {
			LocalVariableDeclaration();
		} else if (StartOf(22)) {
			StatementExpression();
			while (la.kind == 87) {
				Get();
				StatementExpression();
			}
		} else SynErr(224);
	}

	void ForIterator() {
		StatementExpression();
		while (la.kind == 87) {
			Get();
			StatementExpression();
		}
	}

	void CatchClauses() {
		Expect(13);
		if (la.kind == 96) {
			Block();
		} else if (la.kind == 98) {
			Get();
			ClassType();
			if (la.kind == 1) {
				Get();
			}
			Expect(113);
			Block();
			if (la.kind == 13) {
				CatchClauses();
			}
		} else SynErr(225);
	}

	void ResourceAcquisition() {
		if (
#line 1259 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
      IsLocalVarDecl()
#line hidden
) {
			LocalVariableDeclaration();
		} else if (StartOf(22)) {
			Expression();
		} else SynErr(226);
	}

	void Unary() {

#line 1328 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                                  TypeKind dummy; 
#line hidden

		while (
#line 1330 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
        unaryHead[la.kind] || IsTypeCast()
#line hidden
) {
			switch (la.kind) {
			case 108: {
				Get();
				break;
			}
			case 102: {
				Get();
				break;
			}
			case 106: {
				Get();
				break;
			}
			case 115: {
				Get();
				break;
			}
			case 95: {
				Get();
				break;
			}
			case 88: {
				Get();
				break;
			}
			case 116: {
				Get();
				break;
			}
			case 83: {
				Get();
				break;
			}
			case 98: {
				Get();
				Type(
#line 1332 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
               out dummy, false
#line hidden
);
				Expect(113);
				break;
			}
			default: SynErr(227); break;
			}
		}
		Primary();
	}

	void AssignmentOperator() {
		switch (la.kind) {
		case 85: {
			Get();
			break;
		}
		case 109: {
			Get();
			break;
		}
		case 103: {
			Get();
			break;
		}
		case 117: {
			Get();
			break;
		}
		case 89: {
			Get();
			break;
		}
		case 104: {
			Get();
			break;
		}
		case 84: {
			Get();
			break;
		}
		case 107: {
			Get();
			break;
		}
		case 118: {
			Get();
			break;
		}
		case 99: {
			Get();
			break;
		}
		case 93: {
			Get();

#line 1221 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                    int pos = t.pos; 
#line hidden

			Expect(94);

#line 1222 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                    if (pos+1 < t.pos) Error("no whitespace allowed in right shift assignment"); 
#line hidden

			break;
		}
		default: SynErr(228); break;
		}
	}

	void SwitchLabel() {
		if (la.kind == 12) {
			Get();
			Expression();
			Expect(86);
		} else if (la.kind == 20) {
			Get();
			Expect(86);
		} else SynErr(229);
	}

	void NullCoalescingExpr() {
		OrExpr();
		while (la.kind == 127) {
			Get();
			Unary();
			OrExpr();
		}
	}

	void OrExpr() {
		AndExpr();
		while (la.kind == 128) {
			Get();
			Unary();
			AndExpr();
		}
	}

	void AndExpr() {
		BitOrExpr();
		while (la.kind == 129) {
			Get();
			Unary();
			BitOrExpr();
		}
	}

	void BitOrExpr() {
		BitXorExpr();
		while (la.kind == 130) {
			Get();
			Unary();
			BitXorExpr();
		}
	}

	void BitXorExpr() {
		BitAndExpr();
		while (la.kind == 131) {
			Get();
			Unary();
			BitAndExpr();
		}
	}

	void BitAndExpr() {
		EqlExpr();
		while (la.kind == 83) {
			Get();
			Unary();
			EqlExpr();
		}
	}

	void EqlExpr() {
		RelExpr();
		while (la.kind == 92 || la.kind == 105) {
			if (la.kind == 105) {
				Get();
			} else {
				Get();
			}
			Unary();
			RelExpr();
		}
	}

	void RelExpr() {
		ShiftExpr();
		while (StartOf(27)) {
			if (StartOf(28)) {
				if (la.kind == 100) {
					Get();
				} else if (la.kind == 93) {
					Get();
				} else if (la.kind == 132) {
					Get();
				} else if (la.kind == 94) {
					Get();
				} else SynErr(230);
				Unary();
				ShiftExpr();
			} else {
				if (la.kind == 42) {
					Get();
				} else if (la.kind == 7) {
					Get();
				} else SynErr(231);
				ResolvedType();
			}
		}
	}

	void ShiftExpr() {
		AddExpr();
		while (
#line 1314 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
        IsShift()
#line hidden
) {
			if (la.kind == 101) {
				Get();
			} else if (la.kind == 93) {
				Get();
				Expect(93);
			} else SynErr(232);
			Unary();
			AddExpr();
		}
	}

	void AddExpr() {
		MulExpr();
		while (la.kind == 102 || la.kind == 108) {
			if (la.kind == 108) {
				Get();
			} else {
				Get();
			}
			Unary();
			MulExpr();
		}
	}

	void MulExpr() {
		while (la.kind == 116 || la.kind == 133 || la.kind == 134) {
			if (la.kind == 116) {
				Get();
			} else if (la.kind == 133) {
				Get();
			} else {
				Get();
			}
			Unary();
		}
	}

	void Primary() {

#line 1343 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                                  TypeKind type; bool isArrayCreation = false; bool isAssignment2=false;
#line hidden


#line 1344 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                             bool varDecl=false; int begPos = la.pos; 
#line hidden

		switch (la.kind) {
		case 2: case 3: case 4: case 5: case 29: case 47: case 70: {
			Literal();
			break;
		}
		case 98: {
			Get();
			Expression();
			Expect(113);
			break;
		}
		case 9: case 11: case 14: case 19: case 23: case 32: case 39: case 44: case 48: case 59: case 61: case 65: case 73: case 74: case 77: {
			switch (la.kind) {
			case 9: {
				Get();
				break;
			}
			case 11: {
				Get();
				break;
			}
			case 14: {
				Get();
				break;
			}
			case 19: {
				Get();
				break;
			}
			case 23: {
				Get();
				break;
			}
			case 32: {
				Get();
				break;
			}
			case 39: {
				Get();
				break;
			}
			case 44: {
				Get();
				break;
			}
			case 48: {
				Get();
				break;
			}
			case 59: {
				Get();
				break;
			}
			case 61: {
				Get();
				break;
			}
			case 65: {
				Get();
				break;
			}
			case 73: {
				Get();
				break;
			}
			case 74: {
				Get();
				break;
			}
			case 77: {
				Get();
				break;
			}
			}
			Expect(90);
			Expect(1);
			if (
#line 1350 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                      IsGeneric()
#line hidden
) {
				TypeArgumentList();
			}
			break;
		}
		case 1: {

#line 1351 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                           if (IsAssignment()) {isAssignment2 = true;} 
#line hidden

			Get();

#line 1352 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                           varDecl=true; 
#line hidden

			if (la.kind == 91) {
				Get();
				Expect(1);
				Expect(90);
				Expect(1);
			}
			if (
#line 1355 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
          IsGeneric()
#line hidden
) {
				TypeArgumentList();
			}
			break;
		}
		case 68: {
			Get();
			break;
		}
		case 8: {
			Get();
			if (la.kind == 90) {
				Get();
				Expect(1);
				if (
#line 1357 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                             IsGeneric()
#line hidden
) {
					TypeArgumentList();
				}
			} else if (la.kind == 97) {
				Get();
				Expression();
				while (la.kind == 87) {
					Get();
					Expression();
				}
				Expect(112);
			} else SynErr(233);
			break;
		}
		case 46: {
			Get();
			Type(
#line 1360 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
               out type, false
#line hidden
);
			if (la.kind == 98) {
				Get();
				if (StartOf(16)) {
					Argument();
					while (la.kind == 87) {
						Get();
						Argument();
					}
				}
				Expect(113);
			} else if (la.kind == 97) {
				Get();
				Expression();
				while (la.kind == 87) {
					Get();
					Expression();
				}
				Expect(112);
				while (
#line 1365 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                      IsDims()
#line hidden
) {
					Expect(97);
					while (la.kind == 87) {
						Get();
					}
					Expect(112);
				}
				if (la.kind == 96) {
					ArrayInitializer();
				}

#line 1366 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                                                                isArrayCreation = true; 
#line hidden

			} else if (la.kind == 96) {
				ArrayInitializer();

#line 1367 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                                                                if (type != TypeKind.array) Error("array type expected");
                                                                                                                isArrayCreation = true;
                                                                                                             
#line hidden

			} else SynErr(234);
			break;
		}
		case 72: {
			Get();
			Expect(98);
			Type(
#line 1371 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                      out type, true
#line hidden
);
			Expect(113);
			break;
		}
		case 15: {
			Get();
			Expect(98);
			Expression();
			Expect(113);
			break;
		}
		case 75: {
			Get();
			Expect(98);
			Expression();
			Expect(113);
			break;
		}
		case 20: {
			Get();
			Expect(98);
			Primary();
			Expect(113);
			break;
		}
		case 21: {
			Get();
			if (la.kind == 98) {
				Get();
				if (StartOf(14)) {
					AnonymousMethodParameter();
					while (la.kind == 87) {
						Get();
						AnonymousMethodParameter();
					}
				}
				Expect(113);
			}
			Block();
			break;
		}
		case 62: {
			Get();
			Expect(98);
			Type(
#line 1376 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                      out type, false
#line hidden
);
			Expect(113);
			break;
		}
		default: SynErr(235); break;
		}
		while (StartOf(29)) {
			switch (la.kind) {
			case 95: {
				Get();
				break;
			}
			case 88: {
				Get();
				break;
			}
			case 135: {
				Get();
				Expect(1);
				if (
#line 1381 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                       IsGeneric()
#line hidden
) {
					TypeArgumentList();
				}
				break;
			}
			case 90: {
				Get();

#line 1382 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                 if (IsAssignment()) {isAssignment2 = true;} 
#line hidden

				Expect(1);

#line 1383 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                             varDecl=true; 
#line hidden

				if (
#line 1384 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
        IsGeneric()
#line hidden
) {
					TypeArgumentList();
				}
				break;
			}
			case 98: {
				Get();
				if (StartOf(16)) {
					Argument();
					while (la.kind == 87) {
						Get();
						Argument();
					}
				}
				Expect(113);
				break;
			}
			case 97: {

#line 1386 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                                  if (isArrayCreation) Error("element access not allow on array creation"); 
#line hidden

				Get();
				Expression();
				while (la.kind == 87) {
					Get();
					Expression();
				}
				Expect(112);
				break;
			}
			}
		}

#line 1388 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                            if (varDecl == true) 
																				  {
																					  ExpComp.varTbl.add(new TblItem(scanner.buffer.GetString(begPos, la.pos), ExpComp.curFr, begPos, la.pos, isAssignment2));
																				  }
																				
#line hidden

	}

	void Literal() {
		switch (la.kind) {
		case 2: {
			Get();
			break;
		}
		case 3: {
			Get();
			break;
		}
		case 4: {
			Get();
			break;
		}
		case 5: {
			Get();
			break;
		}
		case 70: {
			Get();
			break;
		}
		case 29: {
			Get();
			break;
		}
		case 47: {
			Get();
			break;
		}
		default: SynErr(236); break;
		}
	}

	void AnonymousMethodParameter() {

#line 1398 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                                  TypeKind dummy; 
#line hidden

		if (la.kind == 50 || la.kind == 57) {
			if (la.kind == 57) {
				Get();
			} else {
				Get();
			}
		}
		Type(
#line 1400 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                         out dummy, false
#line hidden
);
		Expect(1);
	}

	void ExpertFrameClassBody() {
		Expect(96);
		if (StartOf(30)) {
			ExpertFrameAttributes(
#line 1476 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                  FrameType.dataFrame
#line hidden
);
		}
		if (la.kind == 139) {
			ExpertOwnClassSlots();
		}
		if (la.kind == 140) {
			ExpertInstanceSlots();
		}
		Expect(111);
	}

	void ExpertFrameInstanceBody() {
		Expect(96);
		if (StartOf(31)) {
			ExpertFrameAttributes(
#line 1478 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                     FrameType.dataFrame
#line hidden
);
		}
		ExpertOwnInsSlots();
		Expect(111);
	}

	void ExpertRulesetParamList() {
		Expect(98);
		ExpertRulesetParam();
		while (la.kind == 87) {
			Get();
			ExpertRulesetParam();
		}
		Expect(113);
	}

	void ExpertFrameRulesetBody() {
		Expect(96);
		if (StartOf(31)) {
			ExpertFrameAttributes(
#line 1588 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                            FrameType.rulesetFrame
#line hidden
);
		}
		Expect(139);
		ExpertRulesetSlots();
		if (la.kind == 147) {
			Get();
			ExpertInitList();
		}
		Expect(111);
	}

	void ExpertFrameAttributes(
#line 1480 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                      FrameType frTp
#line hidden
) {

#line 1480 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                              int begPos = la.pos; 
#line hidden

		while (StartOf(10)) {
			while (la.kind == 97) {
				Attributes();
			}

#line 1481 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                           Modifiers m = new Modifiers(this); 
#line hidden

			ModifierList(
#line 1482 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                       m
#line hidden
);
			ClassMemberDeclaration(
#line 1483 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                 m
#line hidden
);
		}

#line 1484 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
               if (frTp == FrameType.dataFrame)
							 ExpComp.getDataFrame(ExpComp.curFr).csCode = new CScode (begPos, la.pos);
						   else
							 ExpComp.getRuleFrame(ExpComp.curFr).csCode = new CScode (begPos, la.pos); 
					    
#line hidden

	}

	void ExpertOwnClassSlots() {
		Expect(139);
		if (la.kind == 141) {
			ExpertOwnClassIsA();
		}
		while (StartOf(32)) {
			if (StartOf(33)) {
				ExpertSimpleOwnSlot();
			} else {
				ExpertFacetOwnSlot();
			}
		}
	}

	void ExpertInstanceSlots() {
		Expect(140);
		while (StartOf(32)) {
			if (StartOf(33)) {
				ExpertSimpleInsSlot();
			} else {
				ExpertFacetInsSlot();
			}
		}
	}

	void ExpertOwnInsSlots() {
		Expect(139);
		ExpertOwnInsIsA();
		while (StartOf(32)) {
			if (StartOf(33)) {
				ExpertSimpleOwnSlot();
			} else {
				ExpertFacetOwnSlot();
			}
		}
	}

	void ExpertOwnClassIsA() {
		Expect(141);

#line 1500 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                  ExpComp.getDataFrame(ExpComp.curFr).addIsA(la.val); 
#line hidden

		Expect(1);
		if (la.kind == 87) {
			Get();

#line 1501 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                      ExpComp.getDataFrame(ExpComp.curFr).addIsA(la.val); 
#line hidden

			Expect(1);
		}
		Expect(114);
	}

	void ExpertSimpleOwnSlot() {

#line 1516 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                    Slot sl; int begPos; 
#line hidden

		if (
#line 1518 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
      !IsAssignment()
#line hidden
) {

#line 1518 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                   sl = new Slot(); string slotType; 
#line hidden

			ExpertType(
#line 1519 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
             out slotType
#line hidden
);

#line 1519 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                      sl.slotType = slotType; sl.iden=la.val;
#line hidden

			Expect(1);
			if (la.kind == 85) {
				Get();

#line 1522 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                       begPos=la.pos; 
#line hidden

				Expression();

#line 1523 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                            sl.slotValue = scanner.buffer.GetString(begPos, la.pos); 
#line hidden

			}

#line 1524 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                     ExpComp.getDataFrame(ExpComp.curFr).addOwnSlot (sl); 
#line hidden

		} else if (la.kind == 1) {

#line 1526 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                     sl = new Slot(); sl.iden = la.val; 
#line hidden

			Get();
			Expect(85);

#line 1528 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                       begPos=la.pos; 
#line hidden

			Expression();

#line 1529 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                            sl.slotValue = scanner.buffer.GetString (begPos, la.pos); ExpComp.getDataFrame(ExpComp.curFr).addOwnSlot(sl); 
#line hidden

		} else SynErr(237);
		Expect(114);
	}

	void ExpertFacetOwnSlot() {

#line 1533 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                   Slot sl = new Slot(); string slotType; int begPos; 
#line hidden

		Expect(142);
		Expect(96);
		Expect(143);
		ExpertType(
#line 1536 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                out slotType
#line hidden
);
		Expect(114);

#line 1536 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                            sl.slotType = slotType; 
#line hidden

		Expect(144);

#line 1537 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                          begPos = la.pos; 
#line hidden

		Expression();

#line 1538 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                            sl.slotValue = scanner.buffer.GetString(begPos, la.pos); 
#line hidden

		Expect(114);
		if (la.kind == 145) {
			Get();

#line 1541 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                              begPos = la.pos;
#line hidden

			Expression();
			Expect(114);

#line 1542 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                                                      
#line hidden

		}
		Expect(111);

#line 1544 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                       sl.iden = la.val; ExpComp.getDataFrame(ExpComp.curFr).addOwnSlot(sl);  
#line hidden

		Expect(1);
	}

	void ExpertOwnInsIsA() {
		Expect(141);

#line 1496 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                  ExpComp.getDataFrame(ExpComp.curFr).addIsA(la.val); 
#line hidden

		Expect(1);
		Expect(114);
	}

	void ExpertSimpleInsSlot() {

#line 1548 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                    string slotType; int begPos; 
#line hidden

		ExpertType(
#line 1549 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
             out slotType
#line hidden
);

#line 1549 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                      Slot sl = new Slot(Slot.SlotCategory.InstanceSlot); sl.iden=la.val; sl.slotType=slotType; 
#line hidden

		Expect(1);
		if (la.kind == 85) {
			Get();

#line 1552 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                       begPos = la.pos; 
#line hidden

			Expression();

#line 1553 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                            sl.slotValue = scanner.buffer.GetString(begPos, la.pos); 
#line hidden

		}

#line 1554 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                     ExpComp.getDataFrame(ExpComp.curFr).addInstanceSlot(sl); 
#line hidden

		Expect(114);
	}

	void ExpertFacetInsSlot() {

#line 1557 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                   string slotType; int begPos; 
#line hidden

		Expect(142);
		Expect(96);
		Expect(143);
		ExpertType(
#line 1560 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
             out slotType
#line hidden
);

#line 1560 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                      Slot sl = new Slot(Slot.SlotCategory.InstanceSlot); sl.slotType = slotType; 
#line hidden

		Expect(114);
		if (la.kind == 146) {
			Get();

#line 1563 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                begPos=la.pos; 
#line hidden

			Expression();

#line 1564 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                            sl.slotValue = scanner.buffer.GetString (begPos, la.pos); 
#line hidden

			Expect(114);
		}
		Expect(111);

#line 1572 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                       sl.iden = la.val; 
#line hidden

		Expect(1);

#line 1573 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                        ExpComp.getDataFrame(ExpComp.curFr).addInstanceSlot(sl); 
#line hidden

		Expect(114);
	}

	void ExpertType(
#line 1504 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
           out string val
#line hidden
) {

#line 1504 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                  val=""; 
#line hidden

		if (StartOf(13)) {

#line 1505 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
              val=la.val; 
#line hidden

			PrimitiveType();
		} else if (la.kind == 1) {

#line 1507 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                int begPos = la.pos;
#line hidden

			Get();
			if (la.kind == 91) {
				Get();
				Expect(1);
			}
			if (la.kind == 100) {
				TypeArgumentList();
			}
			while (la.kind == 90) {
				Get();
				Expect(1);
				if (la.kind == 100) {
					TypeArgumentList();
				}
			}

#line 1511 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                        val=scanner.buffer.GetString(begPos, la.pos).Trim(); 
#line hidden

		} else if (la.kind == 48 || la.kind == 65) {

#line 1512 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                         val=la.val; 
#line hidden

			InternalClassType();
		} else SynErr(238);
	}

	void ExpertRulesetParam() {

#line 1579 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                   string  parameterType; Parameter prm = new Parameter(); 
#line hidden

		if (la.kind == 57) {

#line 1580 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                     prm.isRef = true; 
#line hidden

			Get();
		}
		ExpertType(
#line 1583 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
            out parameterType
#line hidden
);

#line 1583 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                          prm.parameterType = parameterType; prm.parameterValue=la.val;  
#line hidden

		Expect(1);

#line 1584 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                        ExpComp.getRuleFrame(ExpComp.curFr).addParameter (prm); 
#line hidden

	}

	void ExpertRulesetSlots() {
		ExpertRulesetContextList();
		ExpertRulesetGoal();
		while (la.kind == 150) {
			ExpertRule();
		}
	}

	void ExpertInitList() {
		Expect(147);
		Expect(1);
		Expect(85);
		VariableInitializer();
		while (la.kind == 87) {
			Get();
			Expect(1);
			Expect(85);
			VariableInitializer();
		}
		Expect(114);
	}

	void ExpertRulesetContextList() {
		Expect(148);
		ExpertRulesetContextParam();
		while (la.kind == 87) {
			Get();
			ExpertRulesetContextParam();
		}
		Expect(114);
	}

	void ExpertRulesetContextParam() {

#line 1594 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                         Parameter prm = new Parameter(); 
#line hidden

		if (la.kind == 137) {

#line 1595 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                     prm.isInstance = true; 
#line hidden

			Get();
		}

#line 1597 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                     prm.parameterValue = la.val; ExpComp.getRuleFrame(ExpComp.curFr).addContextItem (prm); 
#line hidden

		Expect(1);
	}

	void ExpertRulesetGoal() {
		Expect(149);

#line 1601 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                         ExpComp.getRuleFrame(ExpComp.curFr).goal = la.val; 
#line hidden

		Expect(1);
		Expect(114);
	}

	void ExpertRule() {

#line 1607 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                              Knowledge.Rule rule = new Rule(); 
#line hidden

		Expect(150);
		Expect(96);
		ExpertIfThenElse(
#line 1609 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                 rule
#line hidden
);
		if (la.kind == 151) {
			Get();

#line 1611 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                            int begPos = la.pos; 
#line hidden

			Expect(5);

#line 1612 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                             rule.comment = scanner.buffer.GetString(begPos, la.pos); 
#line hidden

			Expect(114);
		}
		if (la.kind == 152) {
			Get();
			Expect(2);
		}
		Expect(111);

#line 1619 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                         rule.iden = la.val; ExpComp.getRuleFrame(ExpComp.curFr).addRule (rule); 
#line hidden

		Expect(1);
		Expect(114);
	}

	void ExpertIfThenElse(
#line 1622 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                 Rule rule
#line hidden
) {

#line 1622 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                         int begPos; 
#line hidden

		Expect(36);
		Expect(98);

#line 1623 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                         begPos = la.pos; 
#line hidden

		Expression();

#line 1624 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                            rule.condition = new CScode(begPos, la.pos); 
#line hidden

		Expect(113);
		Expect(153);

#line 1625 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                           begPos = la.pos; 
#line hidden

		EmbeddedStatement();

#line 1626 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                rule.trueBody = new CScode(begPos, la.pos); 
#line hidden

		if (la.kind == 24) {
			Get();

#line 1628 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                        begPos = la.pos; 
#line hidden

			EmbeddedStatement();

#line 1629 "D:\Projects\Аспирантура\svn\Knowledge.CSharp.Converter\Knowledge .NET.atg"
                                rule.falseBody = new CScode(begPos, la.pos); 
#line hidden

		}
	}

	void KnowledgeConceptSimpleDeclaration() {
		Expect(1);
		if (StartOf(34)) {
			KnowledgeConceptBodyDeclaration();
		}
		Expect(114);
	}

	void KnowledgeConceptFullDeclaration() {
		Expect(1);
		Expect(96);
		while (StartOf(34)) {
			KnowledgeConceptBodyDeclaration();
			Expect(114);
		}
		Expect(111);
	}

	void KnowledgeConceptBodyDeclaration() {
		if (la.kind == 154) {
			KnowledgeSubconceptsDeclaration();
		} else if (la.kind == 155) {
			KnowledgeIntersectionDeclaration();
		} else if (la.kind == 156) {
			KnowledgeUnionDeclaration();
		} else if (la.kind == 157) {
			KnowledgeComplementDeclaration();
		} else if (la.kind == 158) {
			KnowledgeDisjointWithDeclaration();
		} else SynErr(239);
	}

	void KnowledgeSubconceptsDeclaration() {
		Expect(154);
		KnowledgeIdentEnum();
	}

	void KnowledgeIntersectionDeclaration() {
		Expect(155);
		KnowledgeIdentEnum();
	}

	void KnowledgeUnionDeclaration() {
		Expect(156);
		KnowledgeIdentEnum();
	}

	void KnowledgeComplementDeclaration() {
		Expect(157);
		KnowledgeIdentEnum();
	}

	void KnowledgeDisjointWithDeclaration() {
		Expect(158);
		Expect(1);
		while (la.kind == 87) {
			Get();
			Expect(1);
		}
		Expect(114);
	}

	void KnowledgeIdentEnum() {
		Expect(1);
		while (la.kind == 87) {
			Get();
			Expect(1);
		}
	}

	void KnowledgeSimpleTypeEnum() {
		if (la.kind == 1 || la.kind == 48 || la.kind == 65) {
			ClassType();
		} else if (StartOf(13)) {
			PrimitiveType();
		} else if (StartOf(23)) {
			IntegralType();
		} else SynErr(240);
		while (la.kind == 87) {
			Get();
			if (la.kind == 1 || la.kind == 48 || la.kind == 65) {
				ClassType();
			} else if (StartOf(13)) {
				PrimitiveType();
			} else if (StartOf(23)) {
				IntegralType();
			} else SynErr(241);
		}
	}

	void KnowledgePropertyModifier() {
		if (la.kind == 163) {
			Get();
		} else if (la.kind == 164) {
			Get();
		} else if (la.kind == 165) {
			Get();
		} else SynErr(242);
	}

	void KnowledgeDatatypePropertyDeclaration() {
		Expect(160);
		Expect(161);
		Expect(1);
		if (la.kind == 162) {
			KnowledgeSubpropertyDeclaration();
		}
		KnowledgeDatatypePropertyBodyDeclaration();
	}

	void KnowledgeObjectPropertyDeclaration() {
		Expect(48);
		Expect(161);
		Expect(1);
		if (la.kind == 162) {
			KnowledgeSubpropertyDeclaration();
		}
		KnowledgeObjectPropertyBodyDeclaration();
	}

	void KnowledgeSubpropertyDeclaration() {
		Expect(162);
		Expect(1);
	}

	void KnowledgeDatatypePropertyBodyDeclaration() {
		Expect(96);
		KnowledgePropertyDomainDeclaration();
		KnowledgeDatatypePropertyRangeDeclaration();
		Expect(111);
	}

	void KnowledgeObjectPropertyBodyDeclaration() {
		Expect(96);
		KnowledgePropertyDomainDeclaration();
		if (la.kind == 167) {
			KnowledgeObjectPropertyRangeDeclaration();
		}
		if (la.kind == 163 || la.kind == 168) {
			KnowledgeInversePropertyDeclaration();
		}
		Expect(111);
	}

	void KnowledgePropertyDomainDeclaration() {
		Expect(166);
		KnowledgeIdentEnum();
		Expect(114);
	}

	void KnowledgeDatatypePropertyRangeDeclaration() {
		Expect(167);
		KnowledgeSimpleTypeEnum();
		Expect(114);
	}

	void KnowledgeObjectPropertyRangeDeclaration() {
		Expect(167);
		KnowledgeIdentEnum();
		Expect(114);
	}

	void KnowledgeInversePropertyDeclaration() {
		if (la.kind == 163) {
			Get();
		}
		Expect(168);
		Expect(1);
		Expect(114);
	}

	void KnowledgeAliasDefenition() {
		Expect(170);
		Expect(5);
		Expect(114);
	}

	void KnowledgeIsADefenition() {
		Expect(141);
		KnowledgeIdentEnum();
		Expect(114);
	}

	void KnowledgePropertyAssignment() {
		Expect(1);
		Expect(85);
		KnowledgePropertyValue();
		Expect(114);
	}

	void KnowledgePropertyValue() {
		if (StartOf(22)) {
			Expression();
		} else if (la.kind == 96) {
			Get();
			KnowledgeIdentEnum();
			Expect(111);
		} else SynErr(243);
	}


		public void Parse() {
			la = new Token();
			la.val = "";		
			Get();
		CS2();

		Expect(0);
		}
		
		bool[,] set = {
		{T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, T,x,x,x, x,T,x,x, x,T,x,x, T,x,x,x, x,x,x,x, x,x,x,x, T,T,x,x, x,T,T,x, x,x,x,T, x,T,T,T, T,x,x,x, T,x,x,x, T,x,T,x, x,x,x,x, x,x,x,x, T,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x},
		{x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, T,x,x,x, x,T,x,x, x,T,x,x, T,x,x,x, x,x,x,x, x,x,x,x, T,T,x,x, x,x,T,x, x,x,x,T, x,T,T,T, T,x,x,x, T,x,x,x, T,x,T,x, x,x,x,x, x,x,x,x, T,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,x,x, x,x,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,T,x, x,x,x,T, x,T,T,T, T,x,x,x, T,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, T,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,T,x,x, x,x,x,x, x,T,x,T, x,x,T,x, x,x,x,T, x,x,x,T, x,x,T,x, x,x,x,x, T,x,x,x, x,x,x,T, x,x,x,x, T,x,T,x, T,x,x,x, x,x,x,x, x,x,x,T, x,T,x,x, x,T,x,x, x,x,x,x, x,T,T,x, x,T,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,T,x,x, x,x,x,x, x,T,x,T, x,x,T,x, x,x,x,T, x,x,x,T, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,T, x,x,x,x, T,x,x,x, T,x,T,x, T,x,x,x, x,T,x,T, x,T,x,x, x,T,x,x, x,x,x,x, x,T,T,x, x,T,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,T,x,x, x,x,T,x, x,T,x,T, x,x,T,x, T,T,x,T, x,T,x,T, x,T,T,T, T,x,x,x, T,x,x,x, x,T,x,T, T,T,x,x, T,x,T,x, T,x,x,T, x,T,T,T, T,x,x,T, T,T,x,x, T,T,T,x, x,x,x,x, x,T,T,x, T,T,x,T, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,T,x,x, x,x,T,x, x,T,x,T, x,x,T,x, T,T,x,T, x,T,x,T, x,T,T,T, T,x,x,x, T,x,x,x, x,T,x,T, T,T,x,x, T,x,T,x, T,x,x,T, x,T,T,T, T,x,x,T, T,T,x,x, T,T,T,x, x,x,x,x, x,T,T,x, T,T,x,T, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,T,x,x, x,x,x,x, x,T,x,T, x,x,T,x, x,x,x,T, x,x,x,T, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,T, x,x,x,x, T,x,x,x, T,x,x,x, x,x,x,x, x,x,x,T, x,T,x,x, x,T,x,x, x,x,x,x, x,T,T,x, x,T,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,T,x,T, x,x,T,x, x,x,x,T, x,x,x,T, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,T, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,T,x,x, x,x,x,x, x,T,x,T, x,x,T,x, x,x,x,T, x,x,x,T, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,T, x,x,x,x, T,x,x,x, T,x,T,x, x,x,x,x, x,T,x,T, x,T,x,x, x,T,x,x, x,x,x,x, x,T,T,x, x,T,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,T,x,x, x,x,x,x, x,T,x,T, x,x,T,x, T,T,x,T, x,T,x,T, x,T,T,T, x,x,x,x, T,x,x,x, x,T,x,T, T,x,x,x, T,x,x,x, T,x,x,x, x,x,x,x, x,x,x,T, x,T,x,x, x,T,T,x, x,x,x,x, x,T,T,x, x,T,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,T,T,T, T,T,x,x, T,T,x,T, x,x,T,T, x,x,x,T, T,T,x,T, x,x,x,x, x,T,x,x, T,x,x,x, x,x,x,T, x,x,x,x, T,x,T,T, T,x,T,x, x,x,x,x, x,T,x,T, x,T,T,x, x,T,x,x, T,x,T,x, T,T,T,T, x,T,x,x, x,x,x,T, x,x,x,x, T,x,x,x, x,x,x,T, x,x,T,x, x,x,T,x, x,x,T,x, T,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,T,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,T,T,T, T,T,x,x, T,T,T,T, x,x,T,T, x,T,T,T, T,T,T,T, x,x,x,x, x,T,x,T, T,T,T,T, T,x,x,T, x,x,x,T, T,x,T,T, T,x,x,x, x,x,x,x, x,x,T,T, x,T,T,x, x,T,x,T, T,T,T,T, T,T,T,T, T,T,T,x, T,x,T,T, x,x,x,x, T,x,x,x, x,x,x,T, T,x,T,x, x,x,T,x, x,x,T,x, T,x,x,x, x,x,T,T, T,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,T,T, x,x,x,x, T,T,T,x, x,x,x,x, T,T,T,x, x,T,x,x, T,x,T,T, T,T,T,x, T,x,x,x, x,x,x,x, x,x,x,T, T,T,T,T, T,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,T,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,T,x, x,x,x,T, x,T,T,T, T,x,x,x, T,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, T,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,T,T,T, T,T,x,x, T,T,x,T, x,x,T,T, x,x,x,T, T,T,x,T, x,x,x,x, x,T,x,x, T,x,x,x, x,x,x,T, x,x,x,x, T,x,T,T, T,x,x,x, x,x,x,x, x,x,x,T, x,T,T,x, x,T,x,x, T,x,T,x, T,T,T,T, x,T,x,x, x,x,x,T, x,x,x,x, T,x,x,x, x,x,x,T, T,x,T,x, x,x,T,x, x,x,T,x, T,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,T,T,T, T,T,x,x, T,T,x,T, x,x,T,T, x,x,x,T, T,T,x,T, x,x,x,x, x,T,x,x, T,x,x,x, x,x,x,T, x,x,x,x, T,x,T,T, T,x,x,x, x,x,x,x, x,x,x,T, x,T,T,x, x,T,x,x, T,x,T,x, T,T,T,T, x,T,x,x, x,x,x,T, x,x,x,x, T,x,x,x, x,x,x,T, x,x,T,x, x,x,T,x, x,x,T,x, T,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,x,x,T, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,T,T,T, T,T,x,x, T,T,T,T, x,x,T,T, x,x,T,T, T,T,T,T, x,x,x,x, x,T,x,T, T,T,T,T, T,x,x,T, x,x,x,T, T,x,T,T, T,x,x,x, x,x,x,x, x,x,T,T, x,T,T,x, x,T,x,T, T,T,T,T, T,T,T,T, T,T,T,x, x,x,T,T, x,x,x,x, T,x,x,x, x,x,x,T, T,x,T,x, x,x,T,x, x,x,T,x, T,x,x,x, x,x,T,T, T,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,T,T,T, T,T,x,x, T,T,x,T, x,x,T,T, x,x,x,T, T,T,x,T, x,x,x,x, x,T,x,x, T,x,x,x, x,x,x,T, x,x,x,x, T,x,T,T, T,x,x,x, x,x,x,x, x,x,x,T, x,T,T,x, x,T,x,x, T,x,T,x, T,T,T,T, x,T,x,x, T,x,x,T, x,x,x,x, T,x,x,x, x,x,x,T, x,x,T,x, x,x,T,x, x,x,T,x, T,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,T,x,x, x,T,x,x, x,T,x,x, x,x,x,T, x,x,x,T, T,x,x,T, x,T,x,x, x,x,x,x, x,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,T,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,T,x, x,x,x,T, x,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,T,x,x, x,x,T,x, x,T,x,T, x,x,T,x, T,T,x,T, x,T,x,T, x,T,T,T, T,x,x,x, T,x,x,x, x,T,x,T, T,T,x,x, T,x,T,x, T,x,x,T, x,T,T,T, T,x,x,T, T,T,x,x, T,T,T,x, x,x,x,x, x,T,T,x, T,T,x,T, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,T, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,T, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,T,x,x, x,x,T,x, x,T,x,T, x,x,T,x, T,T,x,T, x,T,x,T, x,T,T,T, T,x,x,x, T,x,x,x, x,T,x,T, T,T,x,x, T,x,T,x, T,x,x,T, x,T,T,T, T,x,x,T, T,T,x,x, T,T,T,x, x,x,x,x, x,T,T,x, T,T,x,T, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,T,x,x, x,x,x,x, x,T,x,T, x,x,T,x, x,x,x,T, x,x,x,T, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,T, x,x,x,x, T,x,x,x, T,x,x,x, x,x,x,x, x,x,x,T, x,T,x,x, x,T,x,x, x,x,x,x, x,T,T,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,T,x,x, x,x,x,x, x,T,x,T, x,x,T,x, x,x,x,T, x,x,x,T, x,x,x,x, x,x,x,x, T,x,x,x, x,x,x,T, x,x,x,x, T,x,x,x, T,x,x,x, x,x,x,x, x,x,x,T, x,T,x,x, x,T,x,x, x,x,x,x, x,T,T,x, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,T,T, T,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x}

		};
	} // end Parser


	public class Errors {
		public int count = 0;                                    // number of errors detected
		public string errMsgFormat = "-- line {0} col {1}: {2}"; // 0=line, 1=column, 2=text
		private Scanner scanner;

		public Errors(Scanner scanner)
		{
			this.scanner=scanner;
		}
		
		public void SynErr (int line, int col, int n) {
			string s;
			switch (n) {
			case 0: s = "EOF expected"; break;
			case 1: s = "ident expected"; break;
			case 2: s = "intCon expected"; break;
			case 3: s = "realCon expected"; break;
			case 4: s = "charCon expected"; break;
			case 5: s = "stringCon expected"; break;
			case 6: s = "abstract expected"; break;
			case 7: s = "as expected"; break;
			case 8: s = "base expected"; break;
			case 9: s = "bool expected"; break;
			case 10: s = "break expected"; break;
			case 11: s = "byte expected"; break;
			case 12: s = "case expected"; break;
			case 13: s = "catch expected"; break;
			case 14: s = "char expected"; break;
			case 15: s = "checked expected"; break;
			case 16: s = "class expected"; break;
			case 17: s = "const expected"; break;
			case 18: s = "continue expected"; break;
			case 19: s = "decimal expected"; break;
			case 20: s = "default expected"; break;
			case 21: s = "delegate expected"; break;
			case 22: s = "do expected"; break;
			case 23: s = "double expected"; break;
			case 24: s = "else expected"; break;
			case 25: s = "enum expected"; break;
			case 26: s = "event expected"; break;
			case 27: s = "explicit expected"; break;
			case 28: s = "extern expected"; break;
			case 29: s = "false expected"; break;
			case 30: s = "finally expected"; break;
			case 31: s = "fixed expected"; break;
			case 32: s = "float expected"; break;
			case 33: s = "for expected"; break;
			case 34: s = "foreach expected"; break;
			case 35: s = "goto expected"; break;
			case 36: s = "if expected"; break;
			case 37: s = "implicit expected"; break;
			case 38: s = "in expected"; break;
			case 39: s = "int expected"; break;
			case 40: s = "interface expected"; break;
			case 41: s = "internal expected"; break;
			case 42: s = "is expected"; break;
			case 43: s = "lock expected"; break;
			case 44: s = "long expected"; break;
			case 45: s = "namespace expected"; break;
			case 46: s = "new expected"; break;
			case 47: s = "null expected"; break;
			case 48: s = "object expected"; break;
			case 49: s = "operator expected"; break;
			case 50: s = "out expected"; break;
			case 51: s = "override expected"; break;
			case 52: s = "params expected"; break;
			case 53: s = "private expected"; break;
			case 54: s = "protected expected"; break;
			case 55: s = "public expected"; break;
			case 56: s = "readonly expected"; break;
			case 57: s = "ref expected"; break;
			case 58: s = "return expected"; break;
			case 59: s = "sbyte expected"; break;
			case 60: s = "sealed expected"; break;
			case 61: s = "short expected"; break;
			case 62: s = "sizeof expected"; break;
			case 63: s = "stackalloc expected"; break;
			case 64: s = "static expected"; break;
			case 65: s = "string expected"; break;
			case 66: s = "struct expected"; break;
			case 67: s = "switch expected"; break;
			case 68: s = "this expected"; break;
			case 69: s = "throw expected"; break;
			case 70: s = "true expected"; break;
			case 71: s = "try expected"; break;
			case 72: s = "typeof expected"; break;
			case 73: s = "uint expected"; break;
			case 74: s = "ulong expected"; break;
			case 75: s = "unchecked expected"; break;
			case 76: s = "unsafe expected"; break;
			case 77: s = "ushort expected"; break;
			case 78: s = "usingKW expected"; break;
			case 79: s = "virtual expected"; break;
			case 80: s = "void expected"; break;
			case 81: s = "volatile expected"; break;
			case 82: s = "while expected"; break;
			case 83: s = "and expected"; break;
			case 84: s = "andassgn expected"; break;
			case 85: s = "assgn expected"; break;
			case 86: s = "colon expected"; break;
			case 87: s = "comma expected"; break;
			case 88: s = "dec expected"; break;
			case 89: s = "divassgn expected"; break;
			case 90: s = "dot expected"; break;
			case 91: s = "dblcolon expected"; break;
			case 92: s = "eq expected"; break;
			case 93: s = "gt expected"; break;
			case 94: s = "gteq expected"; break;
			case 95: s = "inc expected"; break;
			case 96: s = "lbrace expected"; break;
			case 97: s = "lbrack expected"; break;
			case 98: s = "lpar expected"; break;
			case 99: s = "lshassgn expected"; break;
			case 100: s = "lt expected"; break;
			case 101: s = "ltlt expected"; break;
			case 102: s = "minus expected"; break;
			case 103: s = "minusassgn expected"; break;
			case 104: s = "modassgn expected"; break;
			case 105: s = "neq expected"; break;
			case 106: s = "not expected"; break;
			case 107: s = "orassgn expected"; break;
			case 108: s = "plus expected"; break;
			case 109: s = "plusassgn expected"; break;
			case 110: s = "question expected"; break;
			case 111: s = "rbrace expected"; break;
			case 112: s = "rbrack expected"; break;
			case 113: s = "rpar expected"; break;
			case 114: s = "scolon expected"; break;
			case 115: s = "tilde expected"; break;
			case 116: s = "times expected"; break;
			case 117: s = "timesassgn expected"; break;
			case 118: s = "xorassgn expected"; break;
			case 119: s = "\"#ontology\" expected"; break;
			case 120: s = "\"#concepts\" expected"; break;
			case 121: s = "\"#properties\" expected"; break;
			case 122: s = "\"#individuals\" expected"; break;
			case 123: s = "\"#end_of_ontology\" expected"; break;
			case 124: s = "\"#frames\" expected"; break;
			case 125: s = "\"partial\" expected"; break;
			case 126: s = "\"yield\" expected"; break;
			case 127: s = "\"??\" expected"; break;
			case 128: s = "\"||\" expected"; break;
			case 129: s = "\"&&\" expected"; break;
			case 130: s = "\"|\" expected"; break;
			case 131: s = "\"^\" expected"; break;
			case 132: s = "\"<=\" expected"; break;
			case 133: s = "\"/\" expected"; break;
			case 134: s = "\"%\" expected"; break;
			case 135: s = "\"->\" expected"; break;
			case 136: s = "\"frame\" expected"; break;
			case 137: s = "\"instance\" expected"; break;
			case 138: s = "\"ruleset\" expected"; break;
			case 139: s = "\"own_slots\" expected"; break;
			case 140: s = "\"instance_slots\" expected"; break;
			case 141: s = "\"is_a\" expected"; break;
			case 142: s = "\"facet\" expected"; break;
			case 143: s = "\"type\" expected"; break;
			case 144: s = "\"value\" expected"; break;
			case 145: s = "\"restriction\" expected"; break;
			case 146: s = "\"default_value\" expected"; break;
			case 147: s = "\"init\" expected"; break;
			case 148: s = "\"context\" expected"; break;
			case 149: s = "\"goal\" expected"; break;
			case 150: s = "\"rule\" expected"; break;
			case 151: s = "\"comment\" expected"; break;
			case 152: s = "\"priority\" expected"; break;
			case 153: s = "\"then\" expected"; break;
			case 154: s = "\"is_subconcept_of\" expected"; break;
			case 155: s = "\"is_intersection_of\" expected"; break;
			case 156: s = "\"is_union_of\" expected"; break;
			case 157: s = "\"is_complement_of\" expected"; break;
			case 158: s = "\"disjoint_with\" expected"; break;
			case 159: s = "\"disjoint\" expected"; break;
			case 160: s = "\"datatype\" expected"; break;
			case 161: s = "\"property\" expected"; break;
			case 162: s = "\"is_subproperty_of\" expected"; break;
			case 163: s = "\"functional\" expected"; break;
			case 164: s = "\"transitive\" expected"; break;
			case 165: s = "\"symmetric\" expected"; break;
			case 166: s = "\"domain\" expected"; break;
			case 167: s = "\"range\" expected"; break;
			case 168: s = "\"inverse\" expected"; break;
			case 169: s = "\"individual\" expected"; break;
			case 170: s = "\"alias\" expected"; break;
			case 171: s = "??? expected"; break;
			case 172: s = "invalid NamespaceMemberDeclaration"; break;
			case 173: s = "invalid KnowledgeConceptDeclaration"; break;
			case 174: s = "invalid KnowledgePropertyDeclaration"; break;
			case 175: s = "invalid KnowledgeIndividualDeclaration"; break;
			case 176: s = "invalid ExpertFrameDeclaration"; break;
			case 177: s = "invalid Attributes"; break;
			case 178: s = "invalid TypeDeclaration"; break;
			case 179: s = "invalid TypeDeclaration"; break;
			case 180: s = "invalid TypeParameterConstraintsClause"; break;
			case 181: s = "invalid InterfaceMemberDeclaration"; break;
			case 182: s = "invalid InterfaceMemberDeclaration"; break;
			case 183: s = "invalid InterfaceMemberDeclaration"; break;
			case 184: s = "invalid IntegralType"; break;
			case 185: s = "invalid Type"; break;
			case 186: s = "invalid FormalParameterList"; break;
			case 187: s = "invalid ClassType"; break;
			case 188: s = "invalid ClassMemberDeclaration"; break;
			case 189: s = "invalid ClassMemberDeclaration"; break;
			case 190: s = "invalid StructMemberDeclaration"; break;
			case 191: s = "invalid StructMemberDeclaration"; break;
			case 192: s = "invalid StructMemberDeclaration"; break;
			case 193: s = "invalid StructMemberDeclaration"; break;
			case 194: s = "invalid StructMemberDeclaration"; break;
			case 195: s = "invalid StructMemberDeclaration"; break;
			case 196: s = "invalid StructMemberDeclaration"; break;
			case 197: s = "invalid StructMemberDeclaration"; break;
			case 198: s = "invalid StructMemberDeclaration"; break;
			case 199: s = "invalid StructMemberDeclaration"; break;
			case 200: s = "invalid Expression"; break;
			case 201: s = "invalid EventAccessorDeclarations"; break;
			case 202: s = "invalid EventAccessorDeclarations"; break;
			case 203: s = "invalid OverloadableOp"; break;
			case 204: s = "invalid AccessorDeclarations"; break;
			case 205: s = "invalid AccessorDeclarations"; break;
			case 206: s = "invalid AccessorDeclarations"; break;
			case 207: s = "invalid AccessorDeclarations"; break;
			case 208: s = "invalid InterfaceAccessors"; break;
			case 209: s = "invalid InterfaceAccessors"; break;
			case 210: s = "invalid LocalVariableDeclarator"; break;
			case 211: s = "invalid VariableInitializer"; break;
			case 212: s = "invalid Keyword"; break;
			case 213: s = "invalid AttributeArguments"; break;
			case 214: s = "invalid PrimitiveType"; break;
			case 215: s = "invalid PointerOrArray"; break;
			case 216: s = "invalid ResolvedType"; break;
			case 217: s = "invalid InternalClassType"; break;
			case 218: s = "invalid Statement"; break;
			case 219: s = "invalid EmbeddedStatement"; break;
			case 220: s = "invalid EmbeddedStatement"; break;
			case 221: s = "invalid EmbeddedStatement"; break;
			case 222: s = "invalid EmbeddedStatement"; break;
			case 223: s = "invalid StatementExpression"; break;
			case 224: s = "invalid ForInitializer"; break;
			case 225: s = "invalid CatchClauses"; break;
			case 226: s = "invalid ResourceAcquisition"; break;
			case 227: s = "invalid Unary"; break;
			case 228: s = "invalid AssignmentOperator"; break;
			case 229: s = "invalid SwitchLabel"; break;
			case 230: s = "invalid RelExpr"; break;
			case 231: s = "invalid RelExpr"; break;
			case 232: s = "invalid ShiftExpr"; break;
			case 233: s = "invalid Primary"; break;
			case 234: s = "invalid Primary"; break;
			case 235: s = "invalid Primary"; break;
			case 236: s = "invalid Literal"; break;
			case 237: s = "invalid ExpertSimpleOwnSlot"; break;
			case 238: s = "invalid ExpertType"; break;
			case 239: s = "invalid KnowledgeConceptBodyDeclaration"; break;
			case 240: s = "invalid KnowledgeSimpleTypeEnum"; break;
			case 241: s = "invalid KnowledgeSimpleTypeEnum"; break;
			case 242: s = "invalid KnowledgePropertyModifier"; break;
			case 243: s = "invalid KnowledgePropertyValue"; break;

				default: s = "error " + n; break;
			}
			Error(line, col, s);
		}

		public virtual void Error (int lin, int col, string err) {
			scanner.WriteError(errMsgFormat,scanner.srcFile,lin,col,err);
			count++;
		}

	} // Errors

}/*----------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
-----------------------------------------------------------------------*/

//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by COCO from Scanner.frame.
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

namespace Knowledge {

	public class Token {
		public int kind;    // token kind
		public int pos;     // token position in the source text (starting at 0)
		public int col;     // token column (starting at 0)
		public int line;    // token line (starting at 1)
		public string val;  // token value
		public Token next;  // ML 2005-03-11 Tokens are kept in linked list
	}

	public class Buffer {
		public const char EOF = (char)256;
		const int MAX_BUFFER_LENGTH = 64 * 1024; // 64KB
		byte[] buf;         // input buffer
		int bufStart;       // position of first byte in buffer relative to input stream
		int bufLen;         // length of buffer
		int fileLen;        // length of input stream
		int pos;            // current position in buffer
		Stream stream;      // input stream (seekable)
		bool isUserStream;  // was the stream opened by the user?
		
		public Buffer (Stream s, bool isUserStream) {
			stream = s; this.isUserStream = isUserStream;
			fileLen = bufLen = (int) s.Length;
			if (stream.CanSeek && bufLen > MAX_BUFFER_LENGTH) bufLen = MAX_BUFFER_LENGTH;
			buf = new byte[bufLen];
			bufStart = Int32.MaxValue; // nothing in the buffer so far
			Pos = 0; // setup buffer to position 0 (start)
			if (bufLen == fileLen) Close();
		}
		
		~Buffer() { Close(); }
		
		void Close() {
			if (!isUserStream && stream != null) {
				stream.Close();
				stream = null;
			}
		}
		
		public int Read () {
			if (pos < bufLen) {
				return buf[pos++];
			} else if (Pos < fileLen) {
				Pos = Pos; // shift buffer start to Pos
				return buf[pos++];
			} else {
				return EOF;
			}
		}

		public int Peek () {
			if (pos < bufLen) {
				return buf[pos];
			} else if (Pos < fileLen) {
				Pos = Pos; // shift buffer start to Pos
				return buf[pos];
			} else {
				return EOF;
			}
		}
		
		public string GetString (int beg, int end) {
			int len = end - beg;
			char[] buf = new char[len];
			int oldPos = Pos;
			Pos = beg;
			for (int i = 0; i < len; i++) buf[i] = (char) Read();
			Pos = oldPos;
			return new String(buf);
		}

		public int Pos {
			get { return pos + bufStart; }
			set {
				if (value < 0) value = 0; 
				else if (value > fileLen) value = fileLen;
				if (value >= bufStart && value < bufStart + bufLen) { // already in buffer
					pos = value - bufStart;
				} else if (stream != null) { // must be swapped in
					stream.Seek(value, SeekOrigin.Begin);
					bufLen = stream.Read(buf, 0, buf.Length);
					bufStart = value; pos = 0;
				} else {
					pos = fileLen - bufStart; // make Pos return fileLen
				}
			}
		}
	}

	public class Scanner {
		const char EOL = '\n';
		const int eofSym = 0; /* pdt */
	const int charSetSize = 256;
	const int maxT = 171;
	const int noSym = 171;
	short[] start = {
	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	  0,167, 61,258,  0,254,250, 44, 88, 97,168,166, 79,251,162,252,
	161,159,159,159,159,159,159,159,159,159,164, 98,253,163,165,256,
	160,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
	  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1, 87, 15, 96,257,  1,
	  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
	  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1, 86,255, 95, 99,  0,
	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,
	  0,  0,  0,  0,  0,  1,  0,  0,  0,  0,  1,  0,  0,  0,  0,  0,
	  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
	  1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  1,
	  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
	  1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  1,
	  -1};


		public Buffer buffer; // scanner buffer
		public string srcFile;
		
		Token t;          // current token
		char ch;          // current input character
		int pos;          // column number of current character
		int line;         // line number of current character
		int lineStart;    // start position of current line
		int oldEols;      // EOLs that appeared in a comment;
		BitArray ignore;  // set of characters to be ignored by the scanner
		Token tokens;     // list of tokens already peeked (first token is a dummy)
		Token pt;         // current peek token
		
		char[] tval = new char[128]; // text of current token
		int tlen;         // length of current token
		
		public Scanner (string fileName) {
			srcFile=fileName;
			try {
				Stream stream = new FileStream(fileName, FileMode.Open, FileAccess.Read, FileShare.Read);
				buffer = new Buffer(stream, false);
				Init();
			} catch (IOException) {
				throw new Exception(String.Format("--- Cannot open file {0}", fileName));
			}
		}
		
		public Scanner (Stream s) {
			buffer = new Buffer(s, true);
			Init();
		}
		
		public virtual void WriteLine(string s) 
		{
			Console.WriteLine(s);
		}
		
		public virtual void Write(string s) 
		{
			Console.Write(s);
		}
		
		public virtual void WriteError(string fmt,string file, int lin, int col, string err)
		{
			Console.WriteLine(string.Format(fmt,new object[] {file, lin, col, err}));
		}

		
		void Init() {
			pos = -1; line = 1; lineStart = 0;
			oldEols = 0;
			NextCh();
			ignore = new BitArray(charSetSize+1);
			ignore[' '] = true;  // blanks are always white space
		ignore[9] = true; ignore[10] = true; ignore[13] = true; 
			pt = tokens = new Token();  // first token is a dummy
		}
		
		void NextCh() {
			if (oldEols > 0) { ch = EOL; oldEols--; } 
			else {
				ch = (char)buffer.Read(); pos++;
				// replace isolated '\r' by '\n' in order to make
				// eol handling uniform across Windows, Unix and Mac
				if (ch == '\r' && buffer.Peek() != '\n') ch = EOL;
				if (ch == EOL) { line++; lineStart = pos + 1; }
			}

		}

		void AddCh() {
			if (tlen >= tval.Length) {
				char[] newBuf = new char[2 * tval.Length];
				Array.Copy(tval, 0, newBuf, 0, tval.Length);
				tval = newBuf;
			}
		tval[tlen++] = ch;
			NextCh();
		}



	bool Comment0() {
		int level = 1, line0 = line, lineStart0 = lineStart;
		NextCh();
		if (ch == '/') {
			NextCh();
			for(;;) {
				if (ch == 10) {
					level--;
					if (level == 0) { oldEols = line - line0; NextCh(); return true; }
					NextCh();
				} else if (ch == Buffer.EOF) return false;
				else NextCh();
			}
		} else {
			if (ch==EOL) {line--; lineStart = lineStart0;}
			pos = pos - 2; buffer.Pos = pos+1; NextCh();
		}
		return false;
	}

	bool Comment1() {
		int level = 1, line0 = line, lineStart0 = lineStart;
		NextCh();
		if (ch == '*') {
			NextCh();
			for(;;) {
				if (ch == '*') {
					NextCh();
					if (ch == '/') {
						level--;
						if (level == 0) { oldEols = line - line0; NextCh(); return true; }
						NextCh();
					}
				} else if (ch == Buffer.EOF) return false;
				else NextCh();
			}
		} else {
			if (ch==EOL) {line--; lineStart = lineStart0;}
			pos = pos - 2; buffer.Pos = pos+1; NextCh();
		}
		return false;
	}


		void CheckLiteral() {
		switch (t.val) {
			case "abstract": t.kind = 6; break;
			case "as": t.kind = 7; break;
			case "base": t.kind = 8; break;
			case "bool": t.kind = 9; break;
			case "break": t.kind = 10; break;
			case "byte": t.kind = 11; break;
			case "case": t.kind = 12; break;
			case "catch": t.kind = 13; break;
			case "char": t.kind = 14; break;
			case "checked": t.kind = 15; break;
			case "class": t.kind = 16; break;
			case "const": t.kind = 17; break;
			case "continue": t.kind = 18; break;
			case "decimal": t.kind = 19; break;
			case "default": t.kind = 20; break;
			case "delegate": t.kind = 21; break;
			case "do": t.kind = 22; break;
			case "double": t.kind = 23; break;
			case "else": t.kind = 24; break;
			case "enum": t.kind = 25; break;
			case "event": t.kind = 26; break;
			case "explicit": t.kind = 27; break;
			case "extern": t.kind = 28; break;
			case "false": t.kind = 29; break;
			case "finally": t.kind = 30; break;
			case "fixed": t.kind = 31; break;
			case "float": t.kind = 32; break;
			case "for": t.kind = 33; break;
			case "foreach": t.kind = 34; break;
			case "goto": t.kind = 35; break;
			case "if": t.kind = 36; break;
			case "implicit": t.kind = 37; break;
			case "in": t.kind = 38; break;
			case "int": t.kind = 39; break;
			case "interface": t.kind = 40; break;
			case "internal": t.kind = 41; break;
			case "is": t.kind = 42; break;
			case "lock": t.kind = 43; break;
			case "long": t.kind = 44; break;
			case "namespace": t.kind = 45; break;
			case "new": t.kind = 46; break;
			case "null": t.kind = 47; break;
			case "object": t.kind = 48; break;
			case "operator": t.kind = 49; break;
			case "out": t.kind = 50; break;
			case "override": t.kind = 51; break;
			case "params": t.kind = 52; break;
			case "private": t.kind = 53; break;
			case "protected": t.kind = 54; break;
			case "public": t.kind = 55; break;
			case "readonly": t.kind = 56; break;
			case "ref": t.kind = 57; break;
			case "return": t.kind = 58; break;
			case "sbyte": t.kind = 59; break;
			case "sealed": t.kind = 60; break;
			case "short": t.kind = 61; break;
			case "sizeof": t.kind = 62; break;
			case "stackalloc": t.kind = 63; break;
			case "static": t.kind = 64; break;
			case "string": t.kind = 65; break;
			case "struct": t.kind = 66; break;
			case "switch": t.kind = 67; break;
			case "this": t.kind = 68; break;
			case "throw": t.kind = 69; break;
			case "true": t.kind = 70; break;
			case "try": t.kind = 71; break;
			case "typeof": t.kind = 72; break;
			case "uint": t.kind = 73; break;
			case "ulong": t.kind = 74; break;
			case "unchecked": t.kind = 75; break;
			case "unsafe": t.kind = 76; break;
			case "ushort": t.kind = 77; break;
			case "using": t.kind = 78; break;
			case "virtual": t.kind = 79; break;
			case "void": t.kind = 80; break;
			case "volatile": t.kind = 81; break;
			case "while": t.kind = 82; break;
			case "partial": t.kind = 125; break;
			case "yield": t.kind = 126; break;
			case "frame": t.kind = 136; break;
			case "instance": t.kind = 137; break;
			case "ruleset": t.kind = 138; break;
			case "own_slots": t.kind = 139; break;
			case "instance_slots": t.kind = 140; break;
			case "is_a": t.kind = 141; break;
			case "facet": t.kind = 142; break;
			case "type": t.kind = 143; break;
			case "value": t.kind = 144; break;
			case "restriction": t.kind = 145; break;
			case "default_value": t.kind = 146; break;
			case "init": t.kind = 147; break;
			case "context": t.kind = 148; break;
			case "goal": t.kind = 149; break;
			case "rule": t.kind = 150; break;
			case "comment": t.kind = 151; break;
			case "priority": t.kind = 152; break;
			case "then": t.kind = 153; break;
			case "is_subconcept_of": t.kind = 154; break;
			case "is_intersection_of": t.kind = 155; break;
			case "is_union_of": t.kind = 156; break;
			case "is_complement_of": t.kind = 157; break;
			case "disjoint_with": t.kind = 158; break;
			case "disjoint": t.kind = 159; break;
			case "datatype": t.kind = 160; break;
			case "property": t.kind = 161; break;
			case "is_subproperty_of": t.kind = 162; break;
			case "functional": t.kind = 163; break;
			case "transitive": t.kind = 164; break;
			case "symmetric": t.kind = 165; break;
			case "domain": t.kind = 166; break;
			case "range": t.kind = 167; break;
			case "inverse": t.kind = 168; break;
			case "individual": t.kind = 169; break;
			case "alias": t.kind = 170; break;
			default: break;
		}
		}

		Token NextToken() {
			while (ignore[ch]) NextCh();
		if (ch == '/' && Comment0() ||ch == '/' && Comment1()) return NextToken();
		int apx = 0;
			t = new Token();
			t.pos = pos; t.col = pos - lineStart + 1; t.line = line; 
			int state = start[ch];
			tlen = 0; AddCh();
			
			switch (state) {
				case -1: { t.kind = eofSym; break; } // NextCh already done
				case 0: { t.kind = noSym; break; }   // NextCh already done
			case 1:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'Z' || ch == '_' || ch >= 'a' && ch <= 'z' || ch == 160 || ch == 170 || ch == 181 || ch == 186 || ch >= 192 && ch <= 214 || ch >= 216 && ch <= 246 || ch >= 248 && ch <= 255)) {AddCh(); goto case 1;}
				else if (ch == 92) {AddCh(); goto case 2;}
				else {t.kind = 1; t.val = new String(tval, 0, tlen); CheckLiteral(); return t;}
			case 2:
				if (ch == 'u') {AddCh(); goto case 3;}
				else if (ch == 'U') {AddCh(); goto case 7;}
				else {t.kind = noSym; break;}
			case 3:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 4;}
				else {t.kind = noSym; break;}
			case 4:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 5;}
				else {t.kind = noSym; break;}
			case 5:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 6;}
				else {t.kind = noSym; break;}
			case 6:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 1;}
				else {t.kind = noSym; break;}
			case 7:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 8;}
				else {t.kind = noSym; break;}
			case 8:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 9;}
				else {t.kind = noSym; break;}
			case 9:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 10;}
				else {t.kind = noSym; break;}
			case 10:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 11;}
				else {t.kind = noSym; break;}
			case 11:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 12;}
				else {t.kind = noSym; break;}
			case 12:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 13;}
				else {t.kind = noSym; break;}
			case 13:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 14;}
				else {t.kind = noSym; break;}
			case 14:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 1;}
				else {t.kind = noSym; break;}
			case 15:
				if (ch == 'u') {AddCh(); goto case 16;}
				else if (ch == 'U') {AddCh(); goto case 20;}
				else {t.kind = noSym; break;}
			case 16:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 17;}
				else {t.kind = noSym; break;}
			case 17:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 18;}
				else {t.kind = noSym; break;}
			case 18:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 19;}
				else {t.kind = noSym; break;}
			case 19:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 1;}
				else {t.kind = noSym; break;}
			case 20:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 21;}
				else {t.kind = noSym; break;}
			case 21:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 22;}
				else {t.kind = noSym; break;}
			case 22:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 23;}
				else {t.kind = noSym; break;}
			case 23:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 24;}
				else {t.kind = noSym; break;}
			case 24:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 25;}
				else {t.kind = noSym; break;}
			case 25:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 26;}
				else {t.kind = noSym; break;}
			case 26:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 27;}
				else {t.kind = noSym; break;}
			case 27:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 1;}
				else {t.kind = noSym; break;}
			case 28:
				if ((ch >= '0' && ch <= '9')) {apx = 0; AddCh(); goto case 28;}
				else if (ch == 'U') {apx = 0; AddCh(); goto case 170;}
				else if (ch == 'u') {apx = 0; AddCh(); goto case 171;}
				else if (ch == 'L') {apx = 0; AddCh(); goto case 172;}
				else if (ch == 'l') {apx = 0; AddCh(); goto case 173;}
				else {
					tlen -= apx;
					pos = pos - apx - 1; line = t.line;
					buffer.Pos = pos + 1; NextCh();
					t.kind = 2; break;}
			case 29:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 30;}
				else {t.kind = noSym; break;}
			case 30:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 30;}
				else if (ch == 'U') {AddCh(); goto case 174;}
				else if (ch == 'u') {AddCh(); goto case 175;}
				else if (ch == 'L') {AddCh(); goto case 176;}
				else if (ch == 'l') {AddCh(); goto case 177;}
				else {t.kind = 2; break;}
			case 31:
				{t.kind = 2; break;}
			case 32:
				if ((ch >= '0' && ch <= '9')) {AddCh(); goto case 32;}
				else if ((ch == 'D' || ch == 'F' || ch == 'M' || ch == 'd' || ch == 'f' || ch == 'm')) {AddCh(); goto case 43;}
				else if ((ch == 'E' || ch == 'e')) {AddCh(); goto case 33;}
				else {t.kind = 3; break;}
			case 33:
				if ((ch >= '0' && ch <= '9')) {AddCh(); goto case 35;}
				else if ((ch == '+' || ch == '-')) {AddCh(); goto case 34;}
				else {t.kind = noSym; break;}
			case 34:
				if ((ch >= '0' && ch <= '9')) {AddCh(); goto case 35;}
				else {t.kind = noSym; break;}
			case 35:
				if ((ch >= '0' && ch <= '9')) {AddCh(); goto case 35;}
				else if ((ch == 'D' || ch == 'F' || ch == 'M' || ch == 'd' || ch == 'f' || ch == 'm')) {AddCh(); goto case 43;}
				else {t.kind = 3; break;}
			case 36:
				if ((ch >= '0' && ch <= '9')) {AddCh(); goto case 36;}
				else if ((ch == 'D' || ch == 'F' || ch == 'M' || ch == 'd' || ch == 'f' || ch == 'm')) {AddCh(); goto case 43;}
				else if ((ch == 'E' || ch == 'e')) {AddCh(); goto case 37;}
				else {t.kind = 3; break;}
			case 37:
				if ((ch >= '0' && ch <= '9')) {AddCh(); goto case 39;}
				else if ((ch == '+' || ch == '-')) {AddCh(); goto case 38;}
				else {t.kind = noSym; break;}
			case 38:
				if ((ch >= '0' && ch <= '9')) {AddCh(); goto case 39;}
				else {t.kind = noSym; break;}
			case 39:
				if ((ch >= '0' && ch <= '9')) {AddCh(); goto case 39;}
				else if ((ch == 'D' || ch == 'F' || ch == 'M' || ch == 'd' || ch == 'f' || ch == 'm')) {AddCh(); goto case 43;}
				else {t.kind = 3; break;}
			case 40:
				if ((ch >= '0' && ch <= '9')) {AddCh(); goto case 42;}
				else if ((ch == '+' || ch == '-')) {AddCh(); goto case 41;}
				else {t.kind = noSym; break;}
			case 41:
				if ((ch >= '0' && ch <= '9')) {AddCh(); goto case 42;}
				else {t.kind = noSym; break;}
			case 42:
				if ((ch >= '0' && ch <= '9')) {AddCh(); goto case 42;}
				else if ((ch == 'D' || ch == 'F' || ch == 'M' || ch == 'd' || ch == 'f' || ch == 'm')) {AddCh(); goto case 43;}
				else {t.kind = 3; break;}
			case 43:
				{t.kind = 3; break;}
			case 44:
				if ((ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= '&' || ch >= '(' && ch <= '[' || ch >= ']' && ch <= 255)) {AddCh(); goto case 45;}
				else if (ch == 92) {AddCh(); goto case 178;}
				else {t.kind = noSym; break;}
			case 45:
				if (ch == 39) {AddCh(); goto case 60;}
				else {t.kind = noSym; break;}
			case 46:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 47;}
				else {t.kind = noSym; break;}
			case 47:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 179;}
				else if (ch == 39) {AddCh(); goto case 60;}
				else {t.kind = noSym; break;}
			case 48:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 49;}
				else {t.kind = noSym; break;}
			case 49:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 50;}
				else {t.kind = noSym; break;}
			case 50:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 51;}
				else {t.kind = noSym; break;}
			case 51:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 45;}
				else {t.kind = noSym; break;}
			case 52:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 53;}
				else {t.kind = noSym; break;}
			case 53:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 54;}
				else {t.kind = noSym; break;}
			case 54:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 55;}
				else {t.kind = noSym; break;}
			case 55:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 56;}
				else {t.kind = noSym; break;}
			case 56:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 57;}
				else {t.kind = noSym; break;}
			case 57:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 58;}
				else {t.kind = noSym; break;}
			case 58:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 59;}
				else {t.kind = noSym; break;}
			case 59:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 45;}
				else {t.kind = noSym; break;}
			case 60:
				{t.kind = 4; break;}
			case 61:
				if ((ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= '!' || ch >= '#' && ch <= '[' || ch >= ']' && ch <= 255)) {AddCh(); goto case 61;}
				else if (ch == '"') {AddCh(); goto case 77;}
				else if (ch == 92) {AddCh(); goto case 181;}
				else {t.kind = noSym; break;}
			case 62:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 63;}
				else {t.kind = noSym; break;}
			case 63:
				if ((ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= '!' || ch >= '#' && ch <= '/' || ch >= ':' && ch <= '@' || ch >= 'G' && ch <= '[' || ch >= ']' && ch <= '`' || ch >= 'g' && ch <= 255)) {AddCh(); goto case 61;}
				else if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 182;}
				else if (ch == '"') {AddCh(); goto case 77;}
				else if (ch == 92) {AddCh(); goto case 181;}
				else {t.kind = noSym; break;}
			case 64:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 65;}
				else {t.kind = noSym; break;}
			case 65:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 66;}
				else {t.kind = noSym; break;}
			case 66:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 67;}
				else {t.kind = noSym; break;}
			case 67:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 61;}
				else {t.kind = noSym; break;}
			case 68:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 69;}
				else {t.kind = noSym; break;}
			case 69:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 70;}
				else {t.kind = noSym; break;}
			case 70:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 71;}
				else {t.kind = noSym; break;}
			case 71:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 72;}
				else {t.kind = noSym; break;}
			case 72:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 73;}
				else {t.kind = noSym; break;}
			case 73:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 74;}
				else {t.kind = noSym; break;}
			case 74:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 75;}
				else {t.kind = noSym; break;}
			case 75:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 61;}
				else {t.kind = noSym; break;}
			case 76:
				if (!(ch == '"') && ch != Buffer.EOF) {AddCh(); goto case 76;}
				else if (ch == '"') {AddCh(); goto case 184;}
				else {t.kind = noSym; break;}
			case 77:
				{t.kind = 5; break;}
			case 78:
				{t.kind = 84; break;}
			case 79:
				{t.kind = 87; break;}
			case 80:
				{t.kind = 88; break;}
			case 81:
				{t.kind = 89; break;}
			case 82:
				{t.kind = 91; break;}
			case 83:
				{t.kind = 92; break;}
			case 84:
				{t.kind = 94; break;}
			case 85:
				{t.kind = 95; break;}
			case 86:
				{t.kind = 96; break;}
			case 87:
				{t.kind = 97; break;}
			case 88:
				{t.kind = 98; break;}
			case 89:
				{t.kind = 99; break;}
			case 90:
				{t.kind = 103; break;}
			case 91:
				{t.kind = 104; break;}
			case 92:
				{t.kind = 105; break;}
			case 93:
				{t.kind = 107; break;}
			case 94:
				{t.kind = 109; break;}
			case 95:
				{t.kind = 111; break;}
			case 96:
				{t.kind = 112; break;}
			case 97:
				{t.kind = 113; break;}
			case 98:
				{t.kind = 114; break;}
			case 99:
				{t.kind = 115; break;}
			case 100:
				{t.kind = 117; break;}
			case 101:
				{t.kind = 118; break;}
			case 102:
				if (ch == 'e') {AddCh(); goto case 103;}
				else {t.kind = noSym; break;}
			case 103:
				if (ch == 'f') {AddCh(); goto case 104;}
				else {t.kind = noSym; break;}
			case 104:
				if (ch == 'i') {AddCh(); goto case 105;}
				else {t.kind = noSym; break;}
			case 105:
				if (ch == 'n') {AddCh(); goto case 106;}
				else {t.kind = noSym; break;}
			case 106:
				if (ch == 'e') {AddCh(); goto case 107;}
				else {t.kind = noSym; break;}
			case 107:
				if ((ch == 10 || ch == 13)) {AddCh(); goto case 108;}
				else if ((ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= 255)) {AddCh(); goto case 107;}
				else {t.kind = noSym; break;}
			case 108:
				{t.kind = 172; break;}
			case 109:
				if (ch == 'n') {AddCh(); goto case 110;}
				else {t.kind = noSym; break;}
			case 110:
				if (ch == 'd') {AddCh(); goto case 111;}
				else {t.kind = noSym; break;}
			case 111:
				if (ch == 'e') {AddCh(); goto case 112;}
				else {t.kind = noSym; break;}
			case 112:
				if (ch == 'f') {AddCh(); goto case 113;}
				else {t.kind = noSym; break;}
			case 113:
				if ((ch == 10 || ch == 13)) {AddCh(); goto case 114;}
				else if ((ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= 255)) {AddCh(); goto case 113;}
				else {t.kind = noSym; break;}
			case 114:
				{t.kind = 173; break;}
			case 115:
				if (ch == 'f') {AddCh(); goto case 116;}
				else {t.kind = noSym; break;}
			case 116:
				if ((ch == 10 || ch == 13)) {AddCh(); goto case 117;}
				else if ((ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= 255)) {AddCh(); goto case 116;}
				else {t.kind = noSym; break;}
			case 117:
				{t.kind = 174; break;}
			case 118:
				if (ch == 'f') {AddCh(); goto case 119;}
				else {t.kind = noSym; break;}
			case 119:
				if ((ch == 10 || ch == 13)) {AddCh(); goto case 120;}
				else if ((ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= 255)) {AddCh(); goto case 119;}
				else {t.kind = noSym; break;}
			case 120:
				{t.kind = 175; break;}
			case 121:
				if (ch == 'e') {AddCh(); goto case 122;}
				else {t.kind = noSym; break;}
			case 122:
				if ((ch == 10 || ch == 13)) {AddCh(); goto case 123;}
				else if ((ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= 255)) {AddCh(); goto case 122;}
				else {t.kind = noSym; break;}
			case 123:
				{t.kind = 176; break;}
			case 124:
				if (ch == 'f') {AddCh(); goto case 125;}
				else {t.kind = noSym; break;}
			case 125:
				if ((ch == 10 || ch == 13)) {AddCh(); goto case 126;}
				else if ((ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= 255)) {AddCh(); goto case 125;}
				else {t.kind = noSym; break;}
			case 126:
				{t.kind = 177; break;}
			case 127:
				if (ch == 'i') {AddCh(); goto case 128;}
				else {t.kind = noSym; break;}
			case 128:
				if (ch == 'n') {AddCh(); goto case 129;}
				else {t.kind = noSym; break;}
			case 129:
				if (ch == 'e') {AddCh(); goto case 130;}
				else {t.kind = noSym; break;}
			case 130:
				if ((ch == 10 || ch == 13)) {AddCh(); goto case 131;}
				else if ((ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= 255)) {AddCh(); goto case 130;}
				else {t.kind = noSym; break;}
			case 131:
				{t.kind = 178; break;}
			case 132:
				if (ch == 'r') {AddCh(); goto case 133;}
				else {t.kind = noSym; break;}
			case 133:
				if (ch == 'o') {AddCh(); goto case 134;}
				else {t.kind = noSym; break;}
			case 134:
				if (ch == 'r') {AddCh(); goto case 135;}
				else {t.kind = noSym; break;}
			case 135:
				if ((ch == 10 || ch == 13)) {AddCh(); goto case 136;}
				else if ((ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= 255)) {AddCh(); goto case 135;}
				else {t.kind = noSym; break;}
			case 136:
				{t.kind = 179; break;}
			case 137:
				if (ch == 'a') {AddCh(); goto case 138;}
				else {t.kind = noSym; break;}
			case 138:
				if (ch == 'r') {AddCh(); goto case 139;}
				else {t.kind = noSym; break;}
			case 139:
				if (ch == 'n') {AddCh(); goto case 140;}
				else {t.kind = noSym; break;}
			case 140:
				if (ch == 'i') {AddCh(); goto case 141;}
				else {t.kind = noSym; break;}
			case 141:
				if (ch == 'n') {AddCh(); goto case 142;}
				else {t.kind = noSym; break;}
			case 142:
				if (ch == 'g') {AddCh(); goto case 143;}
				else {t.kind = noSym; break;}
			case 143:
				if ((ch == 10 || ch == 13)) {AddCh(); goto case 144;}
				else if ((ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= 255)) {AddCh(); goto case 143;}
				else {t.kind = noSym; break;}
			case 144:
				{t.kind = 180; break;}
			case 145:
				if (ch == 'e') {AddCh(); goto case 146;}
				else {t.kind = noSym; break;}
			case 146:
				if (ch == 'g') {AddCh(); goto case 147;}
				else {t.kind = noSym; break;}
			case 147:
				if (ch == 'i') {AddCh(); goto case 148;}
				else {t.kind = noSym; break;}
			case 148:
				if (ch == 'o') {AddCh(); goto case 149;}
				else {t.kind = noSym; break;}
			case 149:
				if (ch == 'n') {AddCh(); goto case 150;}
				else {t.kind = noSym; break;}
			case 150:
				if ((ch == 10 || ch == 13)) {AddCh(); goto case 151;}
				else if ((ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= 255)) {AddCh(); goto case 150;}
				else {t.kind = noSym; break;}
			case 151:
				{t.kind = 181; break;}
			case 152:
				if (ch == 'e') {AddCh(); goto case 153;}
				else {t.kind = noSym; break;}
			case 153:
				if (ch == 'g') {AddCh(); goto case 154;}
				else {t.kind = noSym; break;}
			case 154:
				if (ch == 'i') {AddCh(); goto case 155;}
				else {t.kind = noSym; break;}
			case 155:
				if (ch == 'o') {AddCh(); goto case 156;}
				else {t.kind = noSym; break;}
			case 156:
				if (ch == 'n') {AddCh(); goto case 157;}
				else {t.kind = noSym; break;}
			case 157:
				if ((ch == 10 || ch == 13)) {AddCh(); goto case 158;}
				else if ((ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= 255)) {AddCh(); goto case 157;}
				else {t.kind = noSym; break;}
			case 158:
				{t.kind = 182; break;}
			case 159:
				if ((ch >= '0' && ch <= '9')) {apx = 0; AddCh(); goto case 159;}
				else if (ch == 'U') {apx = 0; AddCh(); goto case 170;}
				else if (ch == 'u') {apx = 0; AddCh(); goto case 171;}
				else if (ch == 'L') {apx = 0; AddCh(); goto case 172;}
				else if (ch == 'l') {apx = 0; AddCh(); goto case 173;}
				else if (ch == '.') {apx++; AddCh(); goto case 185;}
				else if ((ch == 'E' || ch == 'e')) {apx = 0; AddCh(); goto case 40;}
				else if ((ch == 'D' || ch == 'F' || ch == 'M' || ch == 'd' || ch == 'f' || ch == 'm')) {apx = 0; AddCh(); goto case 43;}
				else {t.kind = 2; break;}
			case 160:
				if ((ch >= 'A' && ch <= 'Z' || ch == '_' || ch >= 'a' && ch <= 'z' || ch == 170 || ch == 181 || ch == 186 || ch >= 192 && ch <= 214 || ch >= 216 && ch <= 246 || ch >= 248 && ch <= 255)) {AddCh(); goto case 1;}
				else if (ch == 92) {AddCh(); goto case 15;}
				else if (ch == '"') {AddCh(); goto case 76;}
				else {t.kind = noSym; break;}
			case 161:
				if ((ch >= '0' && ch <= '9')) {apx = 0; AddCh(); goto case 159;}
				else if (ch == 'U') {apx = 0; AddCh(); goto case 170;}
				else if (ch == 'u') {apx = 0; AddCh(); goto case 171;}
				else if (ch == 'L') {apx = 0; AddCh(); goto case 172;}
				else if (ch == 'l') {apx = 0; AddCh(); goto case 173;}
				else if (ch == '.') {apx++; AddCh(); goto case 185;}
				else if ((ch == 'X' || ch == 'x')) {apx = 0; AddCh(); goto case 29;}
				else if ((ch == 'E' || ch == 'e')) {apx = 0; AddCh(); goto case 40;}
				else if ((ch == 'D' || ch == 'F' || ch == 'M' || ch == 'd' || ch == 'f' || ch == 'm')) {apx = 0; AddCh(); goto case 43;}
				else {t.kind = 2; break;}
			case 162:
				if ((ch >= '0' && ch <= '9')) {AddCh(); goto case 32;}
				else {t.kind = 90; break;}
			case 163:
				if (ch == '=') {AddCh(); goto case 83;}
				else {t.kind = 85; break;}
			case 164:
				if (ch == ':') {AddCh(); goto case 82;}
				else {t.kind = 86; break;}
			case 165:
				if (ch == '=') {AddCh(); goto case 84;}
				else {t.kind = 93; break;}
			case 166:
				if (ch == '+') {AddCh(); goto case 85;}
				else if (ch == '=') {AddCh(); goto case 94;}
				else {t.kind = 108; break;}
			case 167:
				if (ch == '=') {AddCh(); goto case 92;}
				else {t.kind = 106; break;}
			case 168:
				if (ch == '=') {AddCh(); goto case 100;}
				else {t.kind = 116; break;}
			case 169:
				if ((ch == 9 || ch >= 11 && ch <= 12 || ch == ' ')) {AddCh(); goto case 169;}
				else if (ch == 'd') {AddCh(); goto case 102;}
				else if (ch == 'u') {AddCh(); goto case 109;}
				else if (ch == 'i') {AddCh(); goto case 115;}
				else if (ch == 'e') {AddCh(); goto case 187;}
				else if (ch == 'l') {AddCh(); goto case 127;}
				else if (ch == 'w') {AddCh(); goto case 137;}
				else if (ch == 'r') {AddCh(); goto case 145;}
				else {t.kind = noSym; break;}
			case 170:
				if ((ch == 'L' || ch == 'l')) {AddCh(); goto case 31;}
				else {t.kind = 2; break;}
			case 171:
				if ((ch == 'L' || ch == 'l')) {AddCh(); goto case 31;}
				else {t.kind = 2; break;}
			case 172:
				if ((ch == 'U' || ch == 'u')) {AddCh(); goto case 31;}
				else {t.kind = 2; break;}
			case 173:
				if ((ch == 'U' || ch == 'u')) {AddCh(); goto case 31;}
				else {t.kind = 2; break;}
			case 174:
				if ((ch == 'L' || ch == 'l')) {AddCh(); goto case 31;}
				else {t.kind = 2; break;}
			case 175:
				if ((ch == 'L' || ch == 'l')) {AddCh(); goto case 31;}
				else {t.kind = 2; break;}
			case 176:
				if ((ch == 'U' || ch == 'u')) {AddCh(); goto case 31;}
				else {t.kind = 2; break;}
			case 177:
				if ((ch == 'U' || ch == 'u')) {AddCh(); goto case 31;}
				else {t.kind = 2; break;}
			case 178:
				if ((ch == '"' || ch == 39 || ch == '0' || ch == 92 || ch >= 'a' && ch <= 'b' || ch == 'f' || ch == 'n' || ch == 'r' || ch == 't' || ch == 'v')) {AddCh(); goto case 45;}
				else if (ch == 'x') {AddCh(); goto case 46;}
				else if (ch == 'u') {AddCh(); goto case 48;}
				else if (ch == 'U') {AddCh(); goto case 52;}
				else {t.kind = noSym; break;}
			case 179:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 180;}
				else if (ch == 39) {AddCh(); goto case 60;}
				else {t.kind = noSym; break;}
			case 180:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 45;}
				else if (ch == 39) {AddCh(); goto case 60;}
				else {t.kind = noSym; break;}
			case 181:
				if ((ch == '"' || ch == 39 || ch == '0' || ch == 92 || ch >= 'a' && ch <= 'b' || ch == 'f' || ch == 'n' || ch == 'r' || ch == 't' || ch == 'v')) {AddCh(); goto case 61;}
				else if (ch == 'x') {AddCh(); goto case 62;}
				else if (ch == 'u') {AddCh(); goto case 64;}
				else if (ch == 'U') {AddCh(); goto case 68;}
				else {t.kind = noSym; break;}
			case 182:
				if ((ch >= '0' && ch <= '9' || ch >= 'A' && ch <= 'F' || ch >= 'a' && ch <= 'f')) {AddCh(); goto case 183;}
				else if ((ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= '!' || ch >= '#' && ch <= '/' || ch >= ':' && ch <= '@' || ch >= 'G' && ch <= '[' || ch >= ']' && ch <= '`' || ch >= 'g' && ch <= 255)) {AddCh(); goto case 61;}
				else if (ch == '"') {AddCh(); goto case 77;}
				else if (ch == 92) {AddCh(); goto case 181;}
				else {t.kind = noSym; break;}
			case 183:
				if ((ch <= 9 || ch >= 11 && ch <= 12 || ch >= 14 && ch <= '!' || ch >= '#' && ch <= '[' || ch >= ']' && ch <= 255)) {AddCh(); goto case 61;}
				else if (ch == '"') {AddCh(); goto case 77;}
				else if (ch == 92) {AddCh(); goto case 181;}
				else {t.kind = noSym; break;}
			case 184:
				if (ch == '"') {AddCh(); goto case 76;}
				else {t.kind = 5; break;}
			case 185:
				if ((ch <= '/' || ch >= ':' && ch <= 255)) {apx++; AddCh(); goto case 28;}
				else if ((ch >= '0' && ch <= '9')) {apx = 0; AddCh(); goto case 36;}
				else {t.kind = noSym; break;}
			case 186:
				if (ch == '=') {AddCh(); goto case 89;}
				else {t.kind = 101; break;}
			case 187:
				if (ch == 'l') {AddCh(); goto case 188;}
				else if (ch == 'n') {AddCh(); goto case 189;}
				else if (ch == 'r') {AddCh(); goto case 132;}
				else {t.kind = noSym; break;}
			case 188:
				if (ch == 'i') {AddCh(); goto case 118;}
				else if (ch == 's') {AddCh(); goto case 121;}
				else {t.kind = noSym; break;}
			case 189:
				if (ch == 'd') {AddCh(); goto case 190;}
				else {t.kind = noSym; break;}
			case 190:
				if (ch == 'i') {AddCh(); goto case 124;}
				else if (ch == 'r') {AddCh(); goto case 152;}
				else {t.kind = noSym; break;}
			case 191:
				if (ch == 'n') {AddCh(); goto case 192;}
				else {t.kind = noSym; break;}
			case 192:
				if (ch == 't') {AddCh(); goto case 193;}
				else {t.kind = noSym; break;}
			case 193:
				if (ch == 'o') {AddCh(); goto case 194;}
				else {t.kind = noSym; break;}
			case 194:
				if (ch == 'l') {AddCh(); goto case 195;}
				else {t.kind = noSym; break;}
			case 195:
				if (ch == 'o') {AddCh(); goto case 196;}
				else {t.kind = noSym; break;}
			case 196:
				if (ch == 'g') {AddCh(); goto case 197;}
				else {t.kind = noSym; break;}
			case 197:
				if (ch == 'y') {AddCh(); goto case 198;}
				else {t.kind = noSym; break;}
			case 198:
				{t.kind = 119; break;}
			case 199:
				if (ch == 'o') {AddCh(); goto case 200;}
				else {t.kind = noSym; break;}
			case 200:
				if (ch == 'n') {AddCh(); goto case 201;}
				else {t.kind = noSym; break;}
			case 201:
				if (ch == 'c') {AddCh(); goto case 202;}
				else {t.kind = noSym; break;}
			case 202:
				if (ch == 'e') {AddCh(); goto case 203;}
				else {t.kind = noSym; break;}
			case 203:
				if (ch == 'p') {AddCh(); goto case 204;}
				else {t.kind = noSym; break;}
			case 204:
				if (ch == 't') {AddCh(); goto case 205;}
				else {t.kind = noSym; break;}
			case 205:
				if (ch == 's') {AddCh(); goto case 206;}
				else {t.kind = noSym; break;}
			case 206:
				{t.kind = 120; break;}
			case 207:
				if (ch == 'r') {AddCh(); goto case 208;}
				else {t.kind = noSym; break;}
			case 208:
				if (ch == 'o') {AddCh(); goto case 209;}
				else {t.kind = noSym; break;}
			case 209:
				if (ch == 'p') {AddCh(); goto case 210;}
				else {t.kind = noSym; break;}
			case 210:
				if (ch == 'e') {AddCh(); goto case 211;}
				else {t.kind = noSym; break;}
			case 211:
				if (ch == 'r') {AddCh(); goto case 212;}
				else {t.kind = noSym; break;}
			case 212:
				if (ch == 't') {AddCh(); goto case 213;}
				else {t.kind = noSym; break;}
			case 213:
				if (ch == 'i') {AddCh(); goto case 214;}
				else {t.kind = noSym; break;}
			case 214:
				if (ch == 'e') {AddCh(); goto case 215;}
				else {t.kind = noSym; break;}
			case 215:
				if (ch == 's') {AddCh(); goto case 216;}
				else {t.kind = noSym; break;}
			case 216:
				{t.kind = 121; break;}
			case 217:
				if (ch == 'd') {AddCh(); goto case 218;}
				else {t.kind = noSym; break;}
			case 218:
				if (ch == 'i') {AddCh(); goto case 219;}
				else {t.kind = noSym; break;}
			case 219:
				if (ch == 'v') {AddCh(); goto case 220;}
				else {t.kind = noSym; break;}
			case 220:
				if (ch == 'i') {AddCh(); goto case 221;}
				else {t.kind = noSym; break;}
			case 221:
				if (ch == 'd') {AddCh(); goto case 222;}
				else {t.kind = noSym; break;}
			case 222:
				if (ch == 'u') {AddCh(); goto case 223;}
				else {t.kind = noSym; break;}
			case 223:
				if (ch == 'a') {AddCh(); goto case 224;}
				else {t.kind = noSym; break;}
			case 224:
				if (ch == 'l') {AddCh(); goto case 225;}
				else {t.kind = noSym; break;}
			case 225:
				if (ch == 's') {AddCh(); goto case 226;}
				else {t.kind = noSym; break;}
			case 226:
				{t.kind = 122; break;}
			case 227:
				if (ch == 'o') {AddCh(); goto case 228;}
				else {t.kind = noSym; break;}
			case 228:
				if (ch == 'f') {AddCh(); goto case 229;}
				else {t.kind = noSym; break;}
			case 229:
				if (ch == '_') {AddCh(); goto case 230;}
				else {t.kind = noSym; break;}
			case 230:
				if (ch == 'o') {AddCh(); goto case 231;}
				else {t.kind = noSym; break;}
			case 231:
				if (ch == 'n') {AddCh(); goto case 232;}
				else {t.kind = noSym; break;}
			case 232:
				if (ch == 't') {AddCh(); goto case 233;}
				else {t.kind = noSym; break;}
			case 233:
				if (ch == 'o') {AddCh(); goto case 234;}
				else {t.kind = noSym; break;}
			case 234:
				if (ch == 'l') {AddCh(); goto case 235;}
				else {t.kind = noSym; break;}
			case 235:
				if (ch == 'o') {AddCh(); goto case 236;}
				else {t.kind = noSym; break;}
			case 236:
				if (ch == 'g') {AddCh(); goto case 237;}
				else {t.kind = noSym; break;}
			case 237:
				if (ch == 'y') {AddCh(); goto case 238;}
				else {t.kind = noSym; break;}
			case 238:
				{t.kind = 123; break;}
			case 239:
				if (ch == 'r') {AddCh(); goto case 240;}
				else {t.kind = noSym; break;}
			case 240:
				if (ch == 'a') {AddCh(); goto case 241;}
				else {t.kind = noSym; break;}
			case 241:
				if (ch == 'm') {AddCh(); goto case 242;}
				else {t.kind = noSym; break;}
			case 242:
				if (ch == 'e') {AddCh(); goto case 243;}
				else {t.kind = noSym; break;}
			case 243:
				if (ch == 's') {AddCh(); goto case 244;}
				else {t.kind = noSym; break;}
			case 244:
				{t.kind = 124; break;}
			case 245:
				{t.kind = 127; break;}
			case 246:
				{t.kind = 128; break;}
			case 247:
				{t.kind = 129; break;}
			case 248:
				{t.kind = 132; break;}
			case 249:
				{t.kind = 135; break;}
			case 250:
				if (ch == '=') {AddCh(); goto case 78;}
				else if (ch == '&') {AddCh(); goto case 247;}
				else {t.kind = 83; break;}
			case 251:
				if (ch == '-') {AddCh(); goto case 80;}
				else if (ch == '=') {AddCh(); goto case 90;}
				else if (ch == '>') {AddCh(); goto case 249;}
				else {t.kind = 102; break;}
			case 252:
				if (ch == '=') {AddCh(); goto case 81;}
				else {t.kind = 133; break;}
			case 253:
				if (ch == '<') {AddCh(); goto case 186;}
				else if (ch == '=') {AddCh(); goto case 248;}
				else {t.kind = 100; break;}
			case 254:
				if (ch == '=') {AddCh(); goto case 91;}
				else {t.kind = 134; break;}
			case 255:
				if (ch == '=') {AddCh(); goto case 93;}
				else if (ch == '|') {AddCh(); goto case 246;}
				else {t.kind = 130; break;}
			case 256:
				if (ch == '?') {AddCh(); goto case 245;}
				else {t.kind = 110; break;}
			case 257:
				if (ch == '=') {AddCh(); goto case 101;}
				else {t.kind = 131; break;}
			case 258:
				if ((ch == 9 || ch >= 11 && ch <= 12 || ch == ' ')) {AddCh(); goto case 169;}
				else if (ch == 'd') {AddCh(); goto case 102;}
				else if (ch == 'u') {AddCh(); goto case 109;}
				else if (ch == 'i') {AddCh(); goto case 259;}
				else if (ch == 'e') {AddCh(); goto case 260;}
				else if (ch == 'l') {AddCh(); goto case 127;}
				else if (ch == 'w') {AddCh(); goto case 137;}
				else if (ch == 'r') {AddCh(); goto case 145;}
				else if (ch == 'o') {AddCh(); goto case 191;}
				else if (ch == 'c') {AddCh(); goto case 199;}
				else if (ch == 'p') {AddCh(); goto case 207;}
				else if (ch == 'f') {AddCh(); goto case 239;}
				else {t.kind = noSym; break;}
			case 259:
				if (ch == 'f') {AddCh(); goto case 116;}
				else if (ch == 'n') {AddCh(); goto case 217;}
				else {t.kind = noSym; break;}
			case 260:
				if (ch == 'l') {AddCh(); goto case 188;}
				else if (ch == 'n') {AddCh(); goto case 261;}
				else if (ch == 'r') {AddCh(); goto case 132;}
				else {t.kind = noSym; break;}
			case 261:
				if (ch == 'd') {AddCh(); goto case 262;}
				else {t.kind = noSym; break;}
			case 262:
				if (ch == 'i') {AddCh(); goto case 124;}
				else if (ch == 'r') {AddCh(); goto case 152;}
				else if (ch == '_') {AddCh(); goto case 227;}
				else {t.kind = noSym; break;}

			}
			t.val = new String(tval, 0, tlen);
			return t;
		}
		
		// get the next token (possibly a token already seen during peeking)
		public Token Scan () {
			if (tokens.next == null) {
				return NextToken();
			} else {
				pt = tokens = tokens.next;
				return tokens;
			}
		}

		// peek for the next token, ignore pragmas
		public Token Peek () {
			if (pt.next == null) {
				do {
					pt = pt.next = NextToken();
				} while (pt.kind > maxT); // skip pragmas
			} else {
				do {
					pt = pt.next;
				} while (pt.kind > maxT);
			}
			return pt;
		}
		
		// make sure that peeking starts at the current scan position
		public void ResetPeek () { pt = tokens; }

	} // end Scanner

}