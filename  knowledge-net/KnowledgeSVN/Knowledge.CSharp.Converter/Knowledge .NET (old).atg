using System.Collections;
using System.Text;
using System.Reflection;

using Knowledge;



COMPILER CS

static ArrayList typeNames = null;             // names of declared or imported types
static ArrayList nsNames = new ArrayList();    // names of imported namespaces
static Hashtable aliasNames = new Hashtable(); // alias names of using directives
static string curNamespace = "";               // current namespace
static string assemblyName = null;
public static string ContainingAssembly {       // assembly name of compiled source file
	set { assemblyName = value; }               // must be set by the main program
}

enum TypeKind {simple, array, pointer}

// The $L option let you compile directly within your grammar
// You can comment and uncomment the line to fit your development requirements.
//$L

//

/*------------------------- modifier handling -----------------------------*/

[Flags]
enum Modifier {
	/* available modifiers (reserve one bit per modifier) */
	@new     = 0x0001, @public = 0x0002, @protected= 0x0004, @internal = 0x0008, 
	@private = 0x0010, @unsafe = 0x0020, @static   = 0x0040, @readonly = 0x0080,
	@volatile= 0x0100, @virtual= 0x0200, @sealed   = 0x0400, @override = 0x0800,
	@abstract= 0x1000, @extern = 0x2000,

	/* sets of modifiers that can be attached to certain program elements    *
	 * e.g., "constants" marks all modifiers that may be used with constants */
	none          = 0x0000,
	constants     = @new|@public|@protected|@internal|@private,                                     //0x001f
	nonClassTypes = @new|@public|@protected|@internal|@private|@unsafe|@static,                     //0x007f
	fields        = @new|@public|@protected|@internal|@private|@unsafe|@static|@readonly|@volatile, //0x01ff
	classes       = @new|@public|@protected|@internal|@private|@unsafe|@sealed|@abstract,           //0x143f
	destructors   = @unsafe|@extern,                                                                //0x2020
	constructors  = @public|@protected|@internal|@private|@unsafe|@extern,                          //0x203e
	operators     = @public|@unsafe|@static|@extern,                                                //0x2062
	indexers      = @new|@public|@protected|@internal|@private|@unsafe|@virtual|@sealed|@override|@abstract|@extern,         //0x3e3f
	propEvntMeths = @new|@public|@protected|@internal|@private|@unsafe|@static|@virtual|@sealed|@override|@abstract|@extern, //0x3e7f
	all           = 0x3fff
}

class Modifiers {
	private Modifier cur = Modifier.none;
	
	public void Add (Modifier m) {
		if ((cur & m) == 0) cur |= m;
		else Error("modifier " + m + " already defined");
	}
	
	public void Add (Modifiers m) { Add(m.cur); }

  public bool IsNone { get { return cur == Modifier.none; } }

	public void Check (Modifier allowed) {
		Modifier wrong = cur & (allowed ^ Modifier.all);
		if (wrong != Modifier.none)
		  Error("modifier(s) " + wrong + " not allowed here");
  }
}

/*----------------------------- token sets -------------------------------*/

const int maxTerminals = 160;  // set size

static BitArray NewSet(params int[] values) {
	BitArray a = new BitArray(maxTerminals);
	foreach (int x in values) a[x] = true;
	return a;
}

static BitArray
	unaryOp      = NewSet(_plus, _minus, _not, _tilde, _inc, _dec, _true, _false),
  typeKW       = NewSet(_char, _bool, _object, _string, _sbyte, _byte, _short,
	               _ushort, _int, _uint, _long, _ulong, _float, _double, _decimal),
  unaryHead    = NewSet(_plus, _minus, _not, _tilde, _times, _inc, _dec, _and),
  assnStartOp  = NewSet(_plus, _minus, _not, _tilde, _times),
  castFollower = NewSet(_ident, _intCon, _realCon, _charCon, _stringCon, _lpar, 
                 _new, _this, _base, _null, _checked, _unchecked, _typeof, _sizeof).Or(unaryOp);

/*---------------------------- auxiliary methods ------------------------*/

static void Error (string s) {
	if (errDist >= minErrDist) Errors.Error(la.line, la.col, s);
	errDist = 0;
}

static bool IsTypeCast () {
	if (la.kind != _lpar) return false;
	if (IsSimpleTypeCast()) return true;
	if (assemblyName != null) return CheckTypeCast();
	return GuessTypeCast();
}

// "(" type ("[" {","} "]" | "*") ")"
static bool IsSimpleTypeCast () {
	// assert: la.kind == _lpar
	Scanner.ResetPeek();
	Token pt1 = Scanner.Peek();
	Token pt = Scanner.Peek();
	return (typeKW[pt1.kind] || pt1.kind == _void) && IsPointerOrDims(ref pt) && pt.kind == _rpar;
}

// "(" Qualident ("[" {","} "]" | "*") ")"
static bool CheckTypeCast () {
	// assert: la.kind == _lpar
	string id;
	Scanner.ResetPeek();
	Token pt = Scanner.Peek();
	return IsQualident(ref pt, out id) && IsPointerOrDims(ref pt) && 
	       pt.kind == _rpar && IsType(id);
}

// "(" Qualident ("[" {","} "]" | "*") ")" castFollower
static bool GuessTypeCast () {
	// assert: la.kind == _lpar
	string id;
	Scanner.ResetPeek();
	Token pt = Scanner.Peek();
	if (IsQualident(ref pt, out id) && IsPointerOrDims(ref pt) && pt.kind == _rpar) {
		pt = Scanner.Peek(); // check successor
		return castFollower[pt.kind] || (typeKW[pt.kind] && Scanner.Peek().kind == _dot);
	} else return false;
}

static bool IsType (string qualident) {
	if (typeNames == null) FillTypeNames();
	if (typeNames.BinarySearch(qualident) >= 0) return true;                     // fully qualified type
	if (typeNames.BinarySearch(curNamespace + "." + qualident) >= 0) return true;// local type
	foreach (string ns in nsNames)                                               // imported type
		if (typeNames.BinarySearch(ns + "." + qualident) >= 0) return true;
	foreach (string alias in aliasNames.Keys)                                    // alias type
		if (qualident.StartsWith(alias)) {
			string s = aliasNames[alias] + qualident.Substring(alias.Length);
			if (typeNames.BinarySearch(s) >= 0) return true;
		}
	return false;
}

static void FillTypeNames () {
	if (assemblyName != null && assemblyName.Length > 0) {
		typeNames = new ArrayList();
		Assembly a = Assembly.LoadFrom(assemblyName);
		foreach (Type t in a.GetTypes()) typeNames.Add(t.FullName);
		foreach (AssemblyName refAssembly in a.GetReferencedAssemblies()) {
			a = Assembly.Load(refAssembly);
			foreach(Type t in a.GetExportedTypes())
				if (nsNames.Contains(t.FullName.Substring(0, t.FullName.LastIndexOf('.'))))
					typeNames.Add(t.FullName);
		}
		typeNames.Sort();
	}
}

/* Checks whether the next sequence of tokens is a qualident *
 * and returns the qualident string                          *
 * !!! Proceeds from current peek position !!!               */
static bool IsQualident (ref Token pt, out string qualident) {
	qualident = "";
	if (pt.kind == _ident) {
		qualident = pt.val;
		pt = Scanner.Peek();
		while (pt.kind == _dot) {
			pt = Scanner.Peek();
			if (pt.kind != _ident) return false;
			qualident += "." + pt.val;
			pt = Scanner.Peek();
		}
		return true;
	} else return false;
}

// Return the n-th token after the current lookahead token
static Token Peek (int n) {
	Scanner.ResetPeek();
	Token x = la;
	while (n > 0) { x = Scanner.Peek(); n--; }
	return x;
}

/*-----------------------------------------------------------------*
 * Resolver routines to resolve LL(1) conflicts:                   *                                                  *
 * These routines return a boolean value that indicates            *
 * whether the alternative at hand shall be choosen or not.        *
 * They are used in IF ( ... ) expressions.                        *       
 *-----------------------------------------------------------------*/

// ident "="
static bool IsAssignment () {
	return la.kind == _ident && Peek(1).kind == _assgn;
}

// ident ("," | "=" | ";")
static bool IsFieldDecl () {
	int peek = Peek(1).kind;
	return la.kind == _ident && 
	       (peek == _comma || peek == _assgn || peek == _scolon);
}

/* True, if the comma is not a trailing one, *
 * like the last one in: a, b, c,            */
static bool NotFinalComma () {
	int peek = Peek(1).kind;
	return la.kind == _comma && peek != _rbrace && peek != _rbrack;
}

// "void" "*"
static bool NotVoidPointer () {
	return la.kind == _void && Peek(1).kind != _times;
}

// ("checked" | "unchecked") "{"
static bool UnCheckedAndLBrace () {
	return la.kind == _checked || la.kind == _unchecked &&
	       Peek(1).kind == _lbrace;
}

// "." ident
static bool DotAndIdent () {
	return la.kind == _dot && Peek(1).kind == _ident;
}

// ident ":"
static bool IsLabel () {
	return la.kind == _ident && Peek(1).kind == _colon;
}

// ident "("
static bool IdentAndLPar () {
	return la.kind == _ident && Peek(1).kind == _lpar;
}

// "[" "assembly"
static bool IsGlobalAttrTarget () {
	Token pt = Peek(1);
	return la.kind == _lbrack && pt.kind == _ident && pt.val == "assembly";
}

// "[" ("," | "]")
static bool IsDims () {
	int peek = Peek(1).kind;
	return la.kind == _lbrack && (peek == _comma || peek == _rbrack);
}

// "*" | "[" ("," | "]")
static bool IsPointerOrDims () {
	return la.kind == _times || IsDims();
}

/* skip: { "[" { "," } "]" | "*" }             */
/* !!! Proceeds from current peek position !!! */
static bool IsPointerOrDims (ref Token pt) {
	for (;;) {
		if (pt.kind == _lbrack) {
			do pt = Scanner.Peek();
			while (pt.kind == _comma);
			if (pt.kind != _rbrack) return false;
		} else if (pt.kind != _times) break;
		pt = Scanner.Peek();
	}
	return true;
}

// Type ident (Type can be void*)
static bool IsLocalVarDecl () {
	if (typeKW[la.kind] || la.kind == _void) return true;
	Scanner.ResetPeek();
	Token pt = la;
	string ignore;
	return IsQualident(ref pt, out ignore) && IsPointerOrDims(ref pt) && pt.kind == _ident;
}

/* True, if lookahead is a local attribute target specifier, *
 * i.e. one of "event", "return", "field", "method",         *
 *             "module", "param", "property", or "type"      */
static bool IsLocalAttrTarget () {
	int cur = la.kind;
	string val = la.val;
	return cur == _event || cur == _return ||
	       (Peek(1).kind == _colon &&
	         (val == "field" || val == "method"   || val == "module" ||
	          val == "param" || val == "property" || val == "type"));
}
/*
	C# Expert Functions
*/
static bool IsDeclaration()
{
	return IsType(la.val) && Peek(1).kind == _ident;
}

/*
	Knowledge .NET Functions
*/
static bool IsFullConceptDeclaration()
{
	return la.kind == _ident && Peek(1).kind == _lbrace;
}

/*------------------------------------------------------------------------*
 *----- SCANNER DESCRIPTION ----------------------------------------------*
 *------------------------------------------------------------------------*/

CHARACTERS

	tab                = '\u0009'. /*  9 = tabulator */
	eol                = '\u000a'. /* 10 = line feed */
	cr                 = '\u000d'. /* 13 = carriage return */
	newLine            = cr + eol. /* Line separator character (U+2028) + Paragraph separator character (U+2029) */

	letter             = 'A' .. 'Z' + 'a' .. 'z' + '_'.
	digit              = "0123456789".
	hexDigit           = digit + "ABCDEFabcdef".
	notDigit           = ANY - digit.

	char               = ANY - "'" - '\\' - newLine.
	verbatimStringChar = ANY - '"'.
	regularStringChar  = ANY - '"' - '\\' - newLine.
	notNewLine         = ANY - newLine .
	ws                 = " " + tab + '\u000b' + '\u000c'. /* Any character with Unicode class Zs */


TOKENS

	ident = ['@'] letter { letter | digit }.
  /*--------------------------------------------------------------------------------*/
	intCon =
		( digit {digit} | digit {digit} CONTEXT ("." notDigit)
		| ("0x" | "0X") hexDigit {hexDigit}
		)
		["U" | "u" | "L" | "l" | "UL" | "Ul" | "uL" | "ul" | "LU" | "Lu" | "lU" | "lu"].
  /*--------------------------------------------------------------------------------*/
	realCon =
		"." digit {digit} 
		[("e" | "E") ["+" | "-"] digit {digit}] 
		["F" | "f" | "D" | "d" | "M" | "m"]
	| digit {digit} 
		( "." digit {digit} 
			[("e" | "E" ) ["+" | "-"] digit {digit} ] 
			["F" | "f" | "D" | "d" | "M" | "m"]
		| ("e" | "E") ["+" | "-"] digit {digit}
			["F" | "f" | "D" | "d" | "M" | "m"]
		| "F" | "f" | "D" | "d" | "M" | "m"
		).
  /*--------------------------------------------------------------------------------*/
	charCon =
		"'" (	char
				| "\\\'" | "\\\"" | "\\\\" | "\\0" | "\\a" | "\\b" | "\\f" | "\\n" | "\\r" | "\\t" | "\\v"
				| "\\x" hexDigit [hexDigit] [hexDigit] [hexDigit]
				| "\\u" hexDigit hexDigit hexDigit hexDigit
				| "\\U" hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit
				) 
		"'".
  /*--------------------------------------------------------------------------------*/
	stringCon =
		"\""	{ regularStringChar
					| "\\\'" | "\\\"" | "\\\\" | "\\0" | "\\a" | "\\b" | "\\f" | "\\n" | "\\r" | "\\t" | "\\v"
					| "\\x" hexDigit [hexDigit] [hexDigit] [hexDigit]
					| "\\u" hexDigit hexDigit hexDigit hexDigit
					| "\\U" hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit
					} 
		"\""
	| "@\"" {verbatimStringChar | "\"\""} "\"".


	/*----- keyword names needed in LL(1) resolvers -----*/
	base      = "base".
	bool      = "bool".
	byte      = "byte".
	char      = "char".
	checked   = "checked".
	decimal   = "decimal".
	double    = "double".
	event     = "event".
	false     = "false".
	float     = "float".
	int       = "int".
	long      = "long".
	new       = "new".
	null      = "null".
	object    = "object".
	return    = "return".
	sbyte     = "sbyte".
	short     = "short".
	sizeof    = "sizeof".
	string    = "string".
	this      = "this".
	true      = "true".
	typeof    = "typeof".
	uint      = "uint".
	ulong     = "ulong".
	unchecked = "unchecked".
	ushort    = "ushort".
	void      = "void".

	/*----- operators and special characters needed in LL(1) resolvers --------------*/
	and    = "&".
	assgn  = "=".
	colon  = ":".
	comma  = ",".
	dec    = "--".
	dot    = ".".
	inc    = "++".
	lbrace = "{".
	lbrack = "[".
	lpar   = "(".
	minus  = "-".
	not    = "!".
	plus   = "+".
	rbrace = "}".
	rbrack = "]".
	rpar   = ")".
	scolon = ";".
	tilde  = "~".
	times  = "*".


PRAGMAS

	/* Preprocessor directives.                                               *
	 * The exact parsing of their syntax is left for later processing         */

	ppDefine  = "#" {ws} "define" {notNewLine} newLine.
	ppUndef   = "#" {ws} "undef" {notNewLine} newLine.
	ppIf      = "#" {ws} "if" {notNewLine} newLine.
	ppElif    = "#" {ws} "elif" {notNewLine} newLine.
	ppElse    = "#" {ws} "else" {notNewLine} newLine.
	ppEndif   = "#" {ws} "endif" {notNewLine} newLine.
	ppLine    = "#" {ws} "line" {notNewLine} newLine.
	ppError   = "#" {ws} "error" {notNewLine} newLine.
	ppWarning = "#" {ws} "warning" {notNewLine} newLine.
	ppRegion  = "#" {ws} "region" {notNewLine} newLine.
	ppEndReg  = "#" {ws} "endregion" {notNewLine} newLine.


COMMENTS FROM "/*" TO "*/"
COMMENTS FROM "//" TO eol

IGNORE eol + cr + tab


PRODUCTIONS

/*------------------------------------------------------------------------*
 *--------------------------- Declarations -------------------------------*
 *------------------------------------------------------------------------*/




	CS                                     
	=																(. int begPos = la.pos; .)
	  {UsingDirective}
	  {IF (IsGlobalAttrTarget()) GlobalAttributes} 
	  {NamespaceMember} 
	  																(. ExpComp.precedingCScode = new CScode(begPos, la.pos); .)
			{
				"#ontology" stringCon  
					[
						"#concepts"
						{KnowledgeConceptDeclaration | KnowledgeDisjointDeclaration}
											
					]
					[
						"#properties"
						{KnowledgePropertyDeclaration}
					]
					
					[
						"#individuals"
						{KnowledgeIndividualDeclaration}
					]
					
				"#end_of_ontology"
					[
						stringCon 
					]
			}
			
			"#frames" {ExpertFrameDeclaration}
	  .


/*------------------------------------------------------------------------*/
UsingDirective                         (. string ns, alias = null; .)
= "using" 
	[ IF (IsAssignment()) ident          (. alias = t.val; .)
	  "="]
  Qualident<out ns>                    (. if (alias != null) aliasNames[alias] = ns;
                                          else nsNames.Add(ns);
                                        .) 
  ";".
/*------------------------------------------------------------------------*/
NamespaceMember                        (. Modifiers m = new Modifiers(); 
                                          string id, oldNamespace; .)
= "namespace" Qualident<out id>        (. oldNamespace = curNamespace; curNamespace += id; .)
  "{" {UsingDirective} {NamespaceMember} "}" [";"] 
                                       (. curNamespace = oldNamespace; .)
| {Attributes} {TypeModifier<m>} TypeDecl<m>.
/*------------------------------------------------------------------------*/
TypeDecl<Modifiers m>                  (. TypeKind dummy; .)
=                                      (. m.Check(Modifier.classes); .) 
  "class" ident [ClassBase] ClassBody [";"]
|                                      (. m.Check(Modifier.nonClassTypes); .)
  ( "struct" ident [Base] StructBody  [";"]
  | "interface" ident [Base] "{" {InterfaceMember} "}" [";"]
  | "enum" ident [":" IntType] EnumBody [";"]
  | "delegate" (IF (NotVoidPointer()) "void" | Type<out dummy>) ident "(" [FormalParams] ")" ";"
  ).
/*------------------------------------------------------------------------*/
ClassBase                              (. string id; .)
= ":" ClassType {"," Qualident<out id>}.
/*------------------------------------------------------------------------*/
Base                                   (. string id; .)
= ":" Qualident<out id> {"," Qualident<out id>} .
/*------------------------------------------------------------------------*/
ClassBody
= "{" { {Attributes}                   (. Modifiers m = new Modifiers(); .)
        {MemberModifier<m>} 
        ClassMember<m> 
      } 
  "}".
/*------------------------------------------------------------------------*/
StructBody
= "{" { {Attributes}                   (. Modifiers m = new Modifiers(); .)
        {MemberModifier<m>} 
        StructMember<m> 
      } 
  "}".
/*------------------------------------------------------------------------*/
EnumBody 
= "{" [EnumMember {IF (NotFinalComma()) "," EnumMember} [","] ] "}" .
/*------------------------------------------------------------------------*/
ClassMember<Modifiers m>
= StructMember<m>
| "~" ident "(" ")" (Block | ";").
/*------------------------------------------------------------------------*/
StructMember<Modifiers m>              (. string id; TypeKind dummy; .)
= /*--- constant declaration: */       (. m.Check(Modifier.constants); .)
  "const" Type<out dummy> ident "="    
  Expr { "," ident "="				   	 
  Expr } ";"
| /*--- void method (procedure) declaration: */
  IF (NotVoidPointer())                (. m.Check(Modifier.propEvntMeths); .)
  "void" Qualident<out id> "(" [ FormalParams ] ")" ( Block | ";" )
| /*--- event declaration: */          (. m.Check(Modifier.propEvntMeths); .)
  "event" Type<out dummy> 
  ( IF (IsFieldDecl()) Field {"," Field} ";"
  | Qualident<out id> "{" EventAccessors "}"
  )
| /*--- constructor or static constructor declaration: */
  IF (IdentAndLPar())                  (. m.Check(Modifier.constructors | Modifier.@static); .)
  ident "(" [                          (. m.Check(Modifier.constructors); .)
              FormalParams
            ]
        ")"
        [                              (. m.Check(Modifier.constructors); .)
          ConstructorCall
        ] (Block | ";")  
| /*--- conversion operator declaration: */
                                       (. m.Check(Modifier.operators);
                                          if (m.IsNone) Error("at least one modifier must be set"); 
                                        .)
  ("implicit" | "explicit") "operator" Type<out dummy> "(" Type<out dummy> ident ")" (Block | ";")
| /*--- inner type declaration: */
  TypeDecl<m>
| Type<out dummy>
  ( /*--- operator declaration: */     (. Token op;
                                          m.Check(Modifier.operators);
                                          if (m.IsNone) Error("at least one modifier must be set");
                                        .)
    "operator" OverloadableOp<out op> 
    "(" Type<out dummy> ident 
        ( "," Type<out dummy> ident    (. if (unaryOp[op.kind]) Error("too many operands for unary operator"); .)
        |                              (. if (!unaryOp[op.kind]) Error("too few operands for binary operator"); .)
        )
    ")" (Block | ";")
    
  | /*--- field declaration: */
    IF (IsFieldDecl())                 (. m.Check(Modifier.fields); .)
    Field {"," Field} ";"

  | /*--- unqualified indexer declaration (without interface name): */
                                       (. m.Check(Modifier.indexers); .)
    "this" "[" FormalParams "]" "{" Accessors "}"
    
  | Qualident<out id> 
    ( /*--- "not void" method (function) declaration: */
                                       (. m.Check(Modifier.propEvntMeths); .)
      "(" [FormalParams] ")" (Block | ";")
        
    | /*--- property declaration: */  
      "{" Accessors "}"

    | /*--- qualified indexer declaration (with interface name): */
                                       (. m.Check(Modifier.indexers); .)
      "." "this" "[" FormalParams "]" "{" Accessors "}"
    )
  ).
/*------------------------------------------------------------------------*/
InterfaceMember                        (. TypeKind dummy; .)
= {Attributes} ["new"]
  ( IF (NotVoidPointer()) "void" ident "(" [FormalParams] ")" ";"
  | Type<out dummy> 
		( ident ( "(" [FormalParams] ")" ";" 
						| "{" InterfaceAccessors "}"
						)
		| "this" "[" FormalParams "]" "{" InterfaceAccessors "}"
		)
	| "event" Type<out dummy> ident ";"
  ).
/*------------------------------------------------------------------------*/
EnumMember
= {Attributes} ident ["=" Expr].
/*------------------------------------------------------------------------*/
Field
=												
	ident ["=" Init].
/*------------------------------------------------------------------------*/
LocalVarDecl                           (. TypeKind dummy; .)
= Type<out dummy> LocalVar {"," LocalVar}.
/*------------------------------------------------------------------------*/
LocalVar                               (. TypeKind dummy; .)
=												
	ident [ "=" (Init | "stackalloc" Type<out dummy> "[" Expr "]") ].
/*------------------------------------------------------------------------*/
Init 
= Expr | ArrayInit .
/*------------------------------------------------------------------------*/
ArrayInit
= "{" [Init {IF (NotFinalComma()) "," Init} [","] ] "}".
/*------------------------------------------------------------------------*/
FormalParams                    
= {Attributes}
  ( Par ["," FormalParams]
  | ParArray
  ).
/*------------------------------------------------------------------------*/
Par                                    (. TypeKind dummy; .)
= ["ref" | "out"] Type<out dummy> ident.
/*------------------------------------------------------------------------*/
ParArray                               (. TypeKind dummy; .)
= "params" Type<out dummy> ident. 
/*------------------------------------------------------------------------*/
ConstructorCall
= ":" ("base" | "this") "(" [Argument {"," Argument} ] ")".
/*------------------------------------------------------------------------*/
Argument
= ["ref" | "out"] Expr.
/*------------------------------------------------------------------------*/
Accessors
= {Attributes}
  ( IF (la.val == "get") GetAccessor [{Attributes} SetAccessor]
  | IF (la.val == "set") SetAccessor [{Attributes} GetAccessor]
  | ident                              (. Error("get or set accessor declaration expected"); .)
  ).
/*------------------------------------------------------------------------*/
EventAccessors
= {Attributes}
  (	IF (la.val == "add")    AddAccessor    {Attributes} RemoveAccessor
  |	IF (la.val == "remove") RemoveAccessor {Attributes} AddAccessor
  | ident                              (. Error("add or remove accessor declaration expected"); .)
  ).
/*------------------------------------------------------------------------*/
InterfaceAccessors                     (. bool getFound = false, setFound = false; .)
= {Attributes}
  ( IF (la.val == "get") ident         (. getFound = true; .)
  | IF (la.val == "set") ident         (. setFound = true; .)
  | ident                              (. Error("set or get expected"); .)
  ) ";" 
  [ {Attributes} 
    ( IF (la.val == "get") ident       (. if (getFound) Error("get already declared"); .)
	  | IF (la.val == "set") ident       (. if (setFound) Error("set already declared"); .)
	  | ident                            (. Error("set or get expected"); .)
    ) ";" 
  ].
/*------------------------------------------------------------------------*/
GetAccessor
= ident                                (. if (t.val != "get") Error("get expected"); .)
  (Block | ";").
/*------------------------------------------------------------------------*/
SetAccessor
= ident                                (. if (t.val != "set") Error("set expected"); .)
  (Block | ";").
/*------------------------------------------------------------------------*/
AddAccessor
= ident                                (. if (t.val != "add") Error("add expected"); .)
  Block.
/*------------------------------------------------------------------------*/
RemoveAccessor
= ident                                (. if (t.val != "remove") Error("remove expected"); .)
  Block.
/*------------------------------------------------------------------------*/
GlobalAttributes 
= "[" ident                            (. if (t.val != "assembly") Error("global attribute target specifier (\"assembly\") expected"); .) 
      ":" Attribute {IF (NotFinalComma()) "," Attribute} [","]
  "]".
/*------------------------------------------------------------------------*/
Attributes
= "[" /*--- attribute target specifier: */
      [ IF (IsLocalAttrTarget())
        ( "event" | "return"
        | ident                        (. if (t.val != "field"    && t.val != "method" &&
                                              t.val != "module"   && t.val != "param"  &&
                                              t.val != "property" && t.val != "type")
                                            Error("attribute target specifier (event, return, field," +
                                                  "method, module, param, property, or type) expected");
                                        .)
        ) ":" 
      ] 
      /*--- attribute list: */
      Attribute {IF (NotFinalComma()) "," Attribute} [","] 
  "]".
/*------------------------------------------------------------------------*/
Attribute                              (. string id; .)
= Qualident<out id> [AttributeArguments].
/*------------------------------------------------------------------------*/
AttributeArguments                     (. bool nameFound = false; .)
= "(" [ [ IF (IsAssignment())          (. nameFound = true; .)
          ident "=" 
        ] Expr
        { "," ( IF (IsAssignment())    (. nameFound = true; .)
                ident "="
              |                        (. if (nameFound) Error("no positional argument after named argument"); .)
              ) Expr
        }
      ]
  ")".
/*------------------------------------------------------------------------*/
TypeModifier<Modifiers m>
= "new"                                (. m.Add(Modifier.@new); .)
| "public"                             (. m.Add(Modifier.@public); .)
| "protected"                          (. m.Add(Modifier.@protected); .)
| "internal"                           (. m.Add(Modifier.@internal); .)
| "private"                            (. m.Add(Modifier.@private); .)
| "unsafe"                             (. m.Add(Modifier.@unsafe); .)
| "abstract"                           (. m.Add(Modifier.@abstract); .)
| "sealed"                             (. m.Add(Modifier.@sealed); .)
.
/*------------------------------------------------------------------------*/
MemberModifier<Modifiers m>
= "abstract"                           (. m.Add(Modifier.@abstract); .)
| "extern"                             (. m.Add(Modifier.@extern); .)
| "internal"                           (. m.Add(Modifier.@internal); .)
| "new"                                (. m.Add(Modifier.@new); .)
| "override"                           (. m.Add(Modifier.@override); .)
| "private"                            (. m.Add(Modifier.@private); .)
| "protected"                          (. m.Add(Modifier.@protected); .)
| "public"                             (. m.Add(Modifier.@public); .)
| "readonly"                           (. m.Add(Modifier.@readonly); .)
| "sealed"                             (. m.Add(Modifier.@sealed); .)
| "static"                             (. m.Add(Modifier.@static); .)
| "unsafe"                             (. m.Add(Modifier.@unsafe); .)
| "virtual"                            (. m.Add(Modifier.@virtual); .)
| "volatile"                           (. m.Add(Modifier.@volatile); .)
.

/*------------------------------------------------------------------------*
 *-------------------------------- Types ---------------------------------*
 *------------------------------------------------------------------------*/

/* Attribute "type" is needed for error messages in EmbeddedStatement     *
 * and for array creation expressions                                     */
Type<out TypeKind type>                (. type = TypeKind.simple; .)
= ( SimpleType 
  | ClassType 
  | "void" "*"                         (. type = TypeKind.pointer; .)
  )
  { IF (IsPointerOrDims()) 
    ( "*"                              (. type = TypeKind.pointer; .)
    | "[" {","} "]"                    (. type = TypeKind.array; .)
    ) 
  }.
/*------------------------------------------------------------------------*/
ClassType                              (. string id; .)
= Qualident<out id> | "object" | "string".
/*------------------------------------------------------------------------*/
SimpleType
= IntType | "float" | "double" | "decimal" | "bool".
/*------------------------------------------------------------------------*/
IntType
= "sbyte" | "byte" | "short" | "ushort" | "int" | "uint" | "long" | "ulong" | "char".
/*------------------------------------------------------------------------*/
Qualident<out string qualident>
= ident                                (. qualident = t.val; .)
  { IF (DotAndIdent()) "." ident       (. qualident += "." + t.val; .)
  }									   
  .


/*------------------------------------------------------------------------*
 *------------------------------ Statements ------------------------------*
 *------------------------------------------------------------------------*/

Statement                              (. TypeKind dummy; .)
= IF (IsLabel()) ident ":" Statement
| "const" Type<out dummy> ident "=" Expr {"," ident "=" Expr} ";"
| IF (IsLocalVarDecl()) LocalVarDecl ";"
| EmbeddedStatement 
  /* LL(1) confict between LocalVarDecl and StatementExpr: *
   * ident {"." ident} { "[" ...                           */
.
/*------------------------------------------------------------------------*/
EmbeddedStatement                      (. TypeKind type; .)
= Block
| ";"
| IF (UnCheckedAndLBrace()) ("checked" | "unchecked") Block
| StatementExpr ";"
| "if" "(" Expr ")" EmbeddedStatement ["else" EmbeddedStatement]
| "switch" "(" Expr ")" "{" {SwitchSection} "}"
| "while" "(" Expr ")" EmbeddedStatement
| "do" EmbeddedStatement "while" "(" Expr ")" ";"
| "for" "(" [ForInit] ";" [Expr] ";" [ForInc] ")" EmbeddedStatement
| "foreach" "(" Type<out type> ident "in" Expr ")" EmbeddedStatement
| "break" ";"
| "continue" ";"
| "return" [Expr] ";"
| "throw" [Expr] ";"
| GotoStatement
| TryStatement
| "lock" "(" Expr ")" EmbeddedStatement
| "using" "(" Resource ")" EmbeddedStatement
| "unsafe" Block
| "fixed" 
  "(" Type<out type>                   (. if (type != TypeKind.pointer) Error("can only fix pointer types"); .)
      ident "="						    
      Expr {"," ident "="			   
      Expr} 
  ")" EmbeddedStatement.
/*------------------------------------------------------------------------*/
Block
= "{" {Statement} "}".
/*------------------------------------------------------------------------*/
StatementExpr
=                                      (. bool isAssignment = assnStartOp[la.kind] || IsTypeCast(); .)
  Unary 
  ( AssignOp Expr 
  |                                    (. if (isAssignment) Error("error in assignment."); .)
  ).
/*------------------------------------------------------------------------*/
AssignOp
= "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | ">>=".
/*------------------------------------------------------------------------*/
SwitchSection
= SwitchLabel { SwitchLabel } Statement { Statement }.
/*------------------------------------------------------------------------*/
SwitchLabel
= "case" Expr ":" 
| "default" ":".
/*------------------------------------------------------------------------*/
ForInit
= IF (IsLocalVarDecl()) LocalVarDecl
| StatementExpr { "," StatementExpr }.
/*------------------------------------------------------------------------*/
ForInc
= StatementExpr { "," StatementExpr }.
/*------------------------------------------------------------------------*/
GotoStatement
= "goto" ( ident ";" | "case" Expr ";" | "default" ";" ).
/*------------------------------------------------------------------------*/
TryStatement
= "try" Block
  ( CatchClauses [ "finally" Block ]
  | "finally" Block
  ).
/*------------------------------------------------------------------------*/
CatchClauses
= "catch"
  ( Block
  | "(" ClassType [ident] ")" Block [CatchClauses]
  ).
/*------------------------------------------------------------------------*/
Resource
= (	IF (IsLocalVarDecl()) LocalVarDecl
  |	Expr                         
  ).


/*------------------------------------------------------------------------*
 *----------------------------- Expressions ------------------------------*
 *------------------------------------------------------------------------*/


Expr
= Unary
  ( OrExpr ["?" Expr ":" Expr]
  | AssignOp Expr
  ).
/*------------------------------------------------------------------------*/
OrExpr
= AndExpr {"||" Unary AndExpr}.
/*------------------------------------------------------------------------*/
AndExpr
= BitOrExpr {"&&" Unary BitOrExpr}.
/*------------------------------------------------------------------------*/
BitOrExpr
= BitXorExpr {"|" Unary BitXorExpr} .
/*------------------------------------------------------------------------*/
BitXorExpr
= BitAndExpr {"^" Unary BitAndExpr}.
/*------------------------------------------------------------------------*/
BitAndExpr
= EqlExpr {"&" Unary EqlExpr}.
/*------------------------------------------------------------------------*/
EqlExpr
= RelExpr  {("!=" | "==") Unary RelExpr}.
/*------------------------------------------------------------------------*/
RelExpr                                (. TypeKind dummy; .)
= ShiftExpr
  { ("<" | ">" | "<=" | ">=") Unary ShiftExpr 
  | ("is" | "as") Type<out dummy>
  }.
/*------------------------------------------------------------------------*/
ShiftExpr
= AddExpr {("<<" | ">>") Unary AddExpr}.
/*------------------------------------------------------------------------*/
AddExpr
= MulExpr {( "+" | "-" ) Unary MulExpr}.
/*------------------------------------------------------------------------*/
MulExpr
= {("*" | "/" | "%") Unary}.
/*------------------------------------------------------------------------*/
Unary                                  (. TypeKind dummy; .)
= { IF (unaryHead[la.kind] || IsTypeCast())
		( "+" | "-" | "!" | "~" | "*" | "++" | "--" | "&"
	  | "(" Type<out dummy> ")" 
      /* Problem:  "(" Type ")" from here and                     *
       *           "(" Expr ")" from Primary                      *
       *           are not distinguishable                        *
       * Solution: (in IsTypeCast())                              *
       * use external information from compiled assembly or guess */
    )
	} 
  Primary.
/*------------------------------------------------------------------------*/
Primary                                (. TypeKind type; bool isArrayCreation = false; bool isAssignment2=false; .)
=									   (. bool varDecl=false; int begPos = la.pos; .)
  (									   (.  if (IsAssignment()) {isAssignment2 = true;} .)			
  ident								   (. varDecl=true; .)	
  | Literal
  | "(" Expr ")"
  | ( "bool"   | "byte"   | "char" | "decimal" | "double" /* predefined type member access */
    | "float"  | "int"    | "long" | "object"  | "sbyte"
    | "short"  | "string" | "uint" | "ulong"   | "ushort"
    ) "." ident
  | "this"							   
  | "base" ( "."					 
  ident 
           | "[" Expr {"," Expr} "]" 
           )
  | "new" Type<out type> 
    ( /*--- delegate or object creation expression:                     *
       * Note: a delegate creation expression allows only a single Expr *
       *       not an argument list, but this is not checked here       */
      "(" [Argument {"," Argument}] ")"
    | /*--- array creation expr */     (. isArrayCreation = true; .)
      "["  Expr {"," Expr} "]" {IF (IsDims())  "[" {","} "]"}  [ArrayInit] 
    |                                  (. if (type != TypeKind.array) Error("array type expected");
                                          isArrayCreation = true; .)
      ArrayInit
    )
  | "typeof" "(" (IF (NotVoidPointer()) "void" | Type<out type>) ")"
  | "sizeof" "(" Type<out type> ")"
  | "checked" "(" Expr ")"
  | "unchecked" "(" Expr ")"
  )
  
  { "++" | "--" | "->" ident 
  | "."							   (.  if (IsAssignment()) {isAssignment2 = true;} .)			
	ident						   (.  varDecl=true; .) 		
  | "(" [Argument {"," Argument}] ")"
  |                                    (. if (isArrayCreation) Error("element access not allow on array creation"); .)
    "[" Expr {"," Expr} "]" 
  }									   (. if (varDecl == true) 
										  {
										      ExpComp.varTbl.add(new TblItem(Buffer.GetString(begPos, la.pos), ExpComp.curFr, begPos, la.pos, isAssignment2));
										  } .)
  .
/*------------------------------------------------------------------------*/
Literal
= intCon | realCon | charCon | stringCon | "true" | "false" | "null".
/*------------------------------------------------------------------------*/
OverloadableOp<out Token op>
= ( /* unary operators */
    "+"  | "-"  | "!"    | "~" | "++" | "--" | "true" | "false"
    /* binary operators (plus +, -) */
  | "*"  | "/"  | "%"    | "&" | "|"  | "^"  | "<<"   | ">>"
  | "==" | "!=" | ">"    | "<" | ">=" | "<="
  )                                    (. op = t; .)
  .

/*-----------------------------------------------------------------------------
---------------------------- C# Expert Declarations ---------------------------
-----------------------------------------------------------------------------*/
ExpertFrameDeclaration = "frame" ( 
		("class" 										(. ExpComp.curFr = la.val; ExpComp.addDataFrame(new DataFrame(la.val, DataFrame.FrameTypes.classFrame));    .)
		ident 
		ExpertFrameClassBody)|
		("instance"										(. ExpComp.curFr = la.val; ExpComp.addDataFrame(new DataFrame(la.val, DataFrame.FrameTypes.instanceFrame)); .) 
		ident 
		ExpertFrameInstanceBody) |
		("ruleset"										(. ExpComp.curFr = la.val; ExpComp.addRuleFrame(new RuleFrame(la.val)); .)
		ident 
		[ExpertRulesetParamList] ExpertFrameRulesetBody)
	).


ExpertFrameClassBody = "{" [ExpertFrameAttributes<FrameType.dataFrame>] [ExpertOwnClassSlots] [ExpertInstanceSlots] "}".

ExpertFrameInstanceBody = "{" [ExpertFrameAttributes<FrameType.dataFrame>] ExpertOwnInsSlots "}" .

ExpertFrameAttributes<FrameType frTp> = (. int begPos = la.pos; .)
	 { {Attributes}                   (. Modifiers m = new Modifiers(); .)
       {MemberModifier<m>} 
        ClassMember<m> 
      }					(. if (frTp == FrameType.dataFrame)
							 ExpComp.getDataFrame(ExpComp.curFr).csCode = new CScode (begPos, la.pos);
						   else
							 ExpComp.getRuleFrame(ExpComp.curFr).csCode = new CScode (begPos, la.pos); .).
ExpertOwnClassSlots =  "own_slots" [ExpertOwnClassIsA] {ExpertSimpleOwnSlot | ExpertFacetOwnSlot}.

ExpertOwnInsSlots =  "own_slots" ExpertOwnInsIsA {ExpertSimpleOwnSlot | ExpertFacetOwnSlot}.

ExpertInstanceSlots = "instance_slots" {ExpertSimpleInsSlot | ExpertFacetInsSlot}.

ExpertOwnInsIsA =
	"is_a"								(. ExpComp.getDataFrame(ExpComp.curFr).addIsA(la.val); .)  
	ident ";" .

ExpertOwnClassIsA =
	"is_a"								(. ExpComp.getDataFrame(ExpComp.curFr).addIsA(la.val); .) 
	ident [ ","							(. ExpComp.getDataFrame(ExpComp.curFr).addIsA(la.val); .) 
	ident] ";".

ExpertType<out string val> =			(. val=""; .)
(										(. val=la.val; .)
    SimpleType							
  | Qualident<out val> |				(. val=la.val; .)  
    "object" |							(. val=la.val; .)
    "string"							

). 

ExpertSimpleOwnSlot =										  (. Slot sl; int begPos; .)
	(														  /* declaration of the slot */
		(IF(!IsAssignment())								  (. sl = new Slot(); string slotType; .)
		ExpertType<out slotType>							  (. sl.slotType = slotType; sl.iden=la.val;.)
		ident 
		[													
			"="												  (. begPos=la.pos; .)
			Expr											  (. sl.slotValue = Buffer.GetString(begPos, la.pos); .)	
		]													  (. ExpComp.getDataFrame(ExpComp.curFr).addOwnSlot (sl); .)	
	)  |													  /* assign value to the slot */	
		(													  (. sl = new Slot(); sl.iden = la.val; .)
			ident											  
			"="												  (. begPos=la.pos; .)												   	
			Expr											  (. sl.slotValue = Buffer.GetString (begPos, la.pos); ExpComp.getDataFrame(ExpComp.curFr).addOwnSlot(sl); .)	
		) 
	) ";". 

ExpertFacetOwnSlot =										  (. Slot sl = new Slot(); string slotType; int begPos; .)
	"facet" "{"												  	
	    "type"												   		 
	    ExpertType<out slotType> ";"						  (. sl.slotType = slotType; .)
		"value"												  (. begPos = la.pos; .) 
		Expr												  (. sl.slotValue = Buffer.GetString(begPos, la.pos); .)
		";" 
		[
			"restriction"									  (. begPos = la.pos;.) 
			Expr ";"										  (. /* Buffer.GetString(begPos, la.pos); */ .)
		] 
	"}"														  (. sl.iden = la.val; ExpComp.getDataFrame(ExpComp.curFr).addOwnSlot(sl);  .) 
	ident. 


ExpertSimpleInsSlot =										  (. string slotType; int begPos; .)
		ExpertType<out slotType>							  (. Slot sl = new Slot(Slot.SlotCategory.InstanceSlot); sl.iden=la.val; sl.slotType=slotType; .) 
		ident 
		[
			"="												  (. begPos = la.pos; .) 
			Expr											  (. sl.slotValue = Buffer.GetString(begPos, la.pos); .)
		]													  (. ExpComp.getDataFrame(ExpComp.curFr).addInstanceSlot(sl); .) 	 
		";". 
	 
ExpertFacetInsSlot =										  (. string slotType; int begPos; .)
	"facet" "{" 
		"type" 
		ExpertType<out slotType>							  (. Slot sl = new Slot(Slot.SlotCategory.InstanceSlot); sl.slotType = slotType; .) 
		";" 
		[
			"default_value"									  (. begPos=la.pos; .) 
			Expr											  (. sl.slotValue = Buffer.GetString (begPos, la.pos); .) 	
			";"
		] 
	/*	[
			"restriction"									  (. begPos=la.pos; .)
			Expr											  (. /*sl.restriction = Buffer.GetString (begPos, la.pos);*/.)
			";"
		]	*/
	"}"														  (. sl.iden = la.val; .)	
	ident													  (. ExpComp.getDataFrame(ExpComp.curFr).addInstanceSlot(sl); .) 
	";". 
	
ExpertRulesetParamList =
	"(" ExpertRulesetParam {"," ExpertRulesetParam} ")" .

ExpertRulesetParam =										  (. string  parameterType; Parameter prm = new Parameter(); .)
	[														  (. prm.isRef = true; .)
		"ref"
	] 
	ExpertType<out parameterType>							  (. prm.parameterType = parameterType; prm.parameterValue=la.val;  .)
	ident													  (. ExpComp.getRuleFrame(ExpComp.curFr).addParameter (prm); .)	
	.

ExpertFrameRulesetBody =
	"{" [ExpertFrameAttributes<FrameType.rulesetFrame>] "own_slots" ExpertRulesetSlots ["init" ExpertInitList] "}" .
ExpertRulesetContextList =											  
	"context" 
	ExpertRulesetContextParam 
	{ "," ExpertRulesetContextParam} ";".
	
ExpertRulesetContextParam =									  (. Parameter prm = new Parameter(); .)
	[														  (. prm.isInstance = true; .)	
		"instance"
	]														  (. prm.parameterValue = la.val; ExpComp.getRuleFrame(ExpComp.curFr).addContextItem (prm); .)
	ident. 

ExpertRulesetGoal = 
	"goal"													  (. ExpComp.getRuleFrame(ExpComp.curFr).goal = la.val; .) 
	ident 
";". 

ExpertRulesetSlots = ExpertRulesetContextList ExpertRulesetGoal {ExpertRule} .

ExpertRule =												   (. Knowledge.Rule rule = new Rule(); .)
"rule" "{" 
ExpertIfThenElse<rule> 
[																
	"comment"												   (. int begPos = la.pos; .)
	 stringCon												   (. rule.comment = Buffer.GetString(begPos, la.pos); .)
	 ";"
] 
[															    
	"priority"													
	intCon														
] 
"}"															    (. rule.iden = la.val; ExpComp.getRuleFrame(ExpComp.curFr).addRule (rule); .) 
ident ";".

ExpertIfThenElse<Rule rule> =									(. int begPos; .)
	"if" "("													(. begPos = la.pos; .) 
	Expr														(. rule.condition = new CScode(begPos, la.pos); .)
	")" "then"													(. begPos = la.pos; .) 
	EmbeddedStatement											(. rule.trueBody = new CScode(begPos, la.pos); .)
	[
		"else"													(. begPos = la.pos; .)		 
		EmbeddedStatement										(. rule.falseBody = new CScode(begPos, la.pos); .)
	].

ExpertInitList = "init" ident "=" Init {"," ident "=" Init} ";".

/*-----------------------------------------------------------------------------
-------------------------- Knowledge .NET Declarations ------------------------
-----------------------------------------------------------------------------*/
KnowledgeConceptDeclaration = 
	(
		(
			IF(!IsFullConceptDeclaration())		
			KnowledgeConceptSimpleDeclaration 
		)|
		( 
			KnowledgeConceptFullDeclaration
		)
	).

KnowledgeConceptSimpleDeclaration = 
	ident
	[
		KnowledgeConceptBodyDeclaration
	]
	";".

KnowledgeConceptBodyDeclaration =
	(
		KnowledgeSubconceptsDeclaration
		|
		KnowledgeIntersectionDeclaration
		|
		KnowledgeUnionDeclaration
		|
		KnowledgeComplementDeclaration
		|
		KnowledgeDisjointWithDeclaration
	).

KnowledgeSubconceptsDeclaration = 
	"is_subconcept_of"
	KnowledgeIdentEnum.

KnowledgeIntersectionDeclaration =
	"is_intersection_of"
	KnowledgeIdentEnum.

KnowledgeUnionDeclaration =
	"is_union_of"
	KnowledgeIdentEnum.

KnowledgeComplementDeclaration =
	"is_complement_of"
	KnowledgeIdentEnum.
/*
KnowledgeIsOneOfDeclaration = 
	"is_one_of"
	KnowledgeIdentEnum.
*/

KnowledgeIdentEnum =
	ident
	{
		","
		ident
	}.

KnowledgeSimpleTypeEnum =
	(
		ClassType
		|
		SimpleType
		|
		IntType
	)
	{
		"," 
		(
			ClassType
			|
			SimpleType
			|
			IntType
		)
	}.

KnowledgeConceptFullDeclaration = 
	ident
	"{"
		{
			(
				KnowledgeConceptBodyDeclaration
			)
			";"
		}
	"}".

KnowledgeDisjointWithDeclaration =
 "disjoint_with"
	ident 
	{
		","
		ident
	}
	";".

KnowledgeDisjointDeclaration =
 "disjoint"
	ident 
	{
		","
		ident
	}
	";".

KnowledgePropertyDeclaration =
	KnowledgePropertyModifier
	(
		KnowledgeDatatypePropertyDeclaration
		|
		KnowledgeObjectPropertyDeclaration
	).

KnowledgeDatatypePropertyDeclaration =
	"datatype" "property" ident
	[
		KnowledgeSubpropertyDeclaration
	]
	KnowledgeDatatypePropertyBodyDeclaration.

KnowledgeObjectPropertyDeclaration	 =
	"object" "property" ident
	[
		KnowledgeSubpropertyDeclaration
	]
	KnowledgeObjectPropertyBodyDeclaration.

KnowledgeSubpropertyDeclaration =
	"is_subproperty_of" 
	ident.
	
KnowledgeDatatypePropertyBodyDeclaration=
	"{"
	"domain" 
	KnowledgeIdentEnum 
	";"
	[
		"range"
		KnowledgeSimpleTypeEnum
		";"
	]
	"}".

KnowledgeObjectPropertyBodyDeclaration=
	"{"
		KnowledgePropertyDomainDeclaration
		[
			KnowledgeObjectPropertyRangeDeclaration
		]
		[
			KnowledgeInversePropertyDeclaration
		]
	"}".

KnowledgePropertyModifier=
	"functional"
	|
	"transitive"
	|
	"symmetric".

KnowledgePropertyDomainDeclaration =
	"domain" 
	KnowledgeIdentEnum 
	";".
	
KnowledgeObjectPropertyRangeDeclaration =
	"range"
	KnowledgeIdentEnum
	";".
/*
KnowledgeDatatypePropertyRangeDeclaration =
	"range"
	KnowledgeSimpleTypeEnum
	";".
*/
	
KnowledgeInversePropertyDeclaration =
	[KnowledgePropertyModifier]
	"inverse"
	ident
	";".


KnowledgeIndividualDeclaration =
.

END CS.